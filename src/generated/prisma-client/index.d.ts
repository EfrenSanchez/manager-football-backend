// Code generated by Prisma (prisma@1.30.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  assist: (where?: AssistWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  goal: (where?: GoalWhereInput) => Promise<boolean>;
  injury: (where?: InjuryWhereInput) => Promise<boolean>;
  match: (where?: MatchWhereInput) => Promise<boolean>;
  player: (where?: PlayerWhereInput) => Promise<boolean>;
  staff: (where?: StaffWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  assist: (where: AssistWhereUniqueInput) => AssistPromise;
  assists: (
    args?: {
      where?: AssistWhereInput;
      orderBy?: AssistOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Assist>;
  assistsConnection: (
    args?: {
      where?: AssistWhereInput;
      orderBy?: AssistOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AssistConnectionPromise;
  booking: (where: BookingWhereUniqueInput) => BookingPromise;
  bookings: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Booking>;
  bookingsConnection: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookingConnectionPromise;
  goal: (where: GoalWhereUniqueInput) => GoalPromise;
  goals: (
    args?: {
      where?: GoalWhereInput;
      orderBy?: GoalOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Goal>;
  goalsConnection: (
    args?: {
      where?: GoalWhereInput;
      orderBy?: GoalOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GoalConnectionPromise;
  injury: (where: InjuryWhereUniqueInput) => InjuryPromise;
  injuries: (
    args?: {
      where?: InjuryWhereInput;
      orderBy?: InjuryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Injury>;
  injuriesConnection: (
    args?: {
      where?: InjuryWhereInput;
      orderBy?: InjuryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InjuryConnectionPromise;
  match: (where: MatchWhereUniqueInput) => MatchPromise;
  matches: (
    args?: {
      where?: MatchWhereInput;
      orderBy?: MatchOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Match>;
  matchesConnection: (
    args?: {
      where?: MatchWhereInput;
      orderBy?: MatchOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MatchConnectionPromise;
  player: (where: PlayerWhereUniqueInput) => PlayerPromise;
  players: (
    args?: {
      where?: PlayerWhereInput;
      orderBy?: PlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Player>;
  playersConnection: (
    args?: {
      where?: PlayerWhereInput;
      orderBy?: PlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PlayerConnectionPromise;
  staff: (where: StaffWhereUniqueInput) => StaffPromise;
  staffs: (
    args?: {
      where?: StaffWhereInput;
      orderBy?: StaffOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Staff>;
  staffsConnection: (
    args?: {
      where?: StaffWhereInput;
      orderBy?: StaffOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StaffConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamPromise;
  teams: (
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Team>;
  teamsConnection: (
    args?: {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TeamConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAssist: (data: AssistCreateInput) => AssistPromise;
  updateAssist: (
    args: { data: AssistUpdateInput; where: AssistWhereUniqueInput }
  ) => AssistPromise;
  updateManyAssists: (
    args: { data: AssistUpdateManyMutationInput; where?: AssistWhereInput }
  ) => BatchPayloadPromise;
  upsertAssist: (
    args: {
      where: AssistWhereUniqueInput;
      create: AssistCreateInput;
      update: AssistUpdateInput;
    }
  ) => AssistPromise;
  deleteAssist: (where: AssistWhereUniqueInput) => AssistPromise;
  deleteManyAssists: (where?: AssistWhereInput) => BatchPayloadPromise;
  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (
    args: { data: BookingUpdateInput; where: BookingWhereUniqueInput }
  ) => BookingPromise;
  updateManyBookings: (
    args: { data: BookingUpdateManyMutationInput; where?: BookingWhereInput }
  ) => BatchPayloadPromise;
  upsertBooking: (
    args: {
      where: BookingWhereUniqueInput;
      create: BookingCreateInput;
      update: BookingUpdateInput;
    }
  ) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createGoal: (data: GoalCreateInput) => GoalPromise;
  updateGoal: (
    args: { data: GoalUpdateInput; where: GoalWhereUniqueInput }
  ) => GoalPromise;
  updateManyGoals: (
    args: { data: GoalUpdateManyMutationInput; where?: GoalWhereInput }
  ) => BatchPayloadPromise;
  upsertGoal: (
    args: {
      where: GoalWhereUniqueInput;
      create: GoalCreateInput;
      update: GoalUpdateInput;
    }
  ) => GoalPromise;
  deleteGoal: (where: GoalWhereUniqueInput) => GoalPromise;
  deleteManyGoals: (where?: GoalWhereInput) => BatchPayloadPromise;
  createInjury: (data: InjuryCreateInput) => InjuryPromise;
  updateInjury: (
    args: { data: InjuryUpdateInput; where: InjuryWhereUniqueInput }
  ) => InjuryPromise;
  updateManyInjuries: (
    args: { data: InjuryUpdateManyMutationInput; where?: InjuryWhereInput }
  ) => BatchPayloadPromise;
  upsertInjury: (
    args: {
      where: InjuryWhereUniqueInput;
      create: InjuryCreateInput;
      update: InjuryUpdateInput;
    }
  ) => InjuryPromise;
  deleteInjury: (where: InjuryWhereUniqueInput) => InjuryPromise;
  deleteManyInjuries: (where?: InjuryWhereInput) => BatchPayloadPromise;
  createMatch: (data: MatchCreateInput) => MatchPromise;
  updateMatch: (
    args: { data: MatchUpdateInput; where: MatchWhereUniqueInput }
  ) => MatchPromise;
  updateManyMatches: (
    args: { data: MatchUpdateManyMutationInput; where?: MatchWhereInput }
  ) => BatchPayloadPromise;
  upsertMatch: (
    args: {
      where: MatchWhereUniqueInput;
      create: MatchCreateInput;
      update: MatchUpdateInput;
    }
  ) => MatchPromise;
  deleteMatch: (where: MatchWhereUniqueInput) => MatchPromise;
  deleteManyMatches: (where?: MatchWhereInput) => BatchPayloadPromise;
  createPlayer: (data: PlayerCreateInput) => PlayerPromise;
  updatePlayer: (
    args: { data: PlayerUpdateInput; where: PlayerWhereUniqueInput }
  ) => PlayerPromise;
  updateManyPlayers: (
    args: { data: PlayerUpdateManyMutationInput; where?: PlayerWhereInput }
  ) => BatchPayloadPromise;
  upsertPlayer: (
    args: {
      where: PlayerWhereUniqueInput;
      create: PlayerCreateInput;
      update: PlayerUpdateInput;
    }
  ) => PlayerPromise;
  deletePlayer: (where: PlayerWhereUniqueInput) => PlayerPromise;
  deleteManyPlayers: (where?: PlayerWhereInput) => BatchPayloadPromise;
  createStaff: (data: StaffCreateInput) => StaffPromise;
  updateStaff: (
    args: { data: StaffUpdateInput; where: StaffWhereUniqueInput }
  ) => StaffPromise;
  updateManyStaffs: (
    args: { data: StaffUpdateManyMutationInput; where?: StaffWhereInput }
  ) => BatchPayloadPromise;
  upsertStaff: (
    args: {
      where: StaffWhereUniqueInput;
      create: StaffCreateInput;
      update: StaffUpdateInput;
    }
  ) => StaffPromise;
  deleteStaff: (where: StaffWhereUniqueInput) => StaffPromise;
  deleteManyStaffs: (where?: StaffWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (
    args: { data: TeamUpdateInput; where: TeamWhereUniqueInput }
  ) => TeamPromise;
  updateManyTeams: (
    args: { data: TeamUpdateManyMutationInput; where?: TeamWhereInput }
  ) => BatchPayloadPromise;
  upsertTeam: (
    args: {
      where: TeamWhereUniqueInput;
      create: TeamCreateInput;
      update: TeamUpdateInput;
    }
  ) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  assist: (
    where?: AssistSubscriptionWhereInput
  ) => AssistSubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  goal: (
    where?: GoalSubscriptionWhereInput
  ) => GoalSubscriptionPayloadSubscription;
  injury: (
    where?: InjurySubscriptionWhereInput
  ) => InjurySubscriptionPayloadSubscription;
  match: (
    where?: MatchSubscriptionWhereInput
  ) => MatchSubscriptionPayloadSubscription;
  player: (
    where?: PlayerSubscriptionWhereInput
  ) => PlayerSubscriptionPayloadSubscription;
  staff: (
    where?: StaffSubscriptionWhereInput
  ) => StaffSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Competiton = "FRIENDLY" | "LEAGUE" | "CUP";

export type ColorCard = "YELLOW" | "RED";

export type PlayerPosition =
  | "GOALKEEPER"
  | "CENTRE_BACK"
  | "LEFT_BACK"
  | "RIGHT_BACK"
  | "DEFENSIVE_MIDFIELD"
  | "CENTRE_MIDFIELD"
  | "LEFT_MIDFIELD"
  | "RIGHT_MIDFIELD"
  | "ATTACKING_MIDFIELD"
  | "LEFT_WINGER"
  | "RIGHT_WINGER"
  | "SECOND_STRIKE"
  | "CENTRE_FORWARD";

export type Foot = "LEFT" | "RIGHT" | "AMB" | "UNKNOWN";

export type PlayerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nick_ASC"
  | "nick_DESC"
  | "shirtNumber_ASC"
  | "shirtNumber_DESC"
  | "imgUrl_ASC"
  | "imgUrl_DESC"
  | "captain_ASC"
  | "captain_DESC"
  | "position_ASC"
  | "position_DESC"
  | "altPosition_ASC"
  | "altPosition_DESC"
  | "foot_ASC"
  | "foot_DESC"
  | "injured_ASC"
  | "injured_DESC";

export type StaffOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nick_ASC"
  | "nick_DESC"
  | "imgUrl_ASC"
  | "imgUrl_DESC"
  | "role_ASC"
  | "role_DESC";

export type MatchOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "jornada_ASC"
  | "jornada_DESC"
  | "finished_ASC"
  | "finished_DESC"
  | "homeTeam_ASC"
  | "homeTeam_DESC"
  | "win_ASC"
  | "win_DESC"
  | "competition_ASC"
  | "competition_DESC"
  | "referees_ASC"
  | "referees_DESC"
  | "desc_ASC"
  | "desc_DESC";

export type GoalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "min_ASC"
  | "min_DESC"
  | "desc_ASC"
  | "desc_DESC";

export type AssistOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "min_ASC"
  | "min_DESC"
  | "desc_ASC"
  | "desc_DESC";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "min_ASC"
  | "min_DESC"
  | "desc_ASC"
  | "desc_DESC"
  | "card_ASC"
  | "card_DESC";

export type InjuryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startAt_ASC"
  | "startAt_DESC"
  | "endAt_ASC"
  | "endAt_DESC"
  | "desc_ASC"
  | "desc_DESC";

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "logoUrl_ASC"
  | "logoUrl_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AssistWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PlayerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nick?: String;
  nick_not?: String;
  nick_in?: String[] | String;
  nick_not_in?: String[] | String;
  nick_lt?: String;
  nick_lte?: String;
  nick_gt?: String;
  nick_gte?: String;
  nick_contains?: String;
  nick_not_contains?: String;
  nick_starts_with?: String;
  nick_not_starts_with?: String;
  nick_ends_with?: String;
  nick_not_ends_with?: String;
  shirtNumber?: Int;
  shirtNumber_not?: Int;
  shirtNumber_in?: Int[] | Int;
  shirtNumber_not_in?: Int[] | Int;
  shirtNumber_lt?: Int;
  shirtNumber_lte?: Int;
  shirtNumber_gt?: Int;
  shirtNumber_gte?: Int;
  imgUrl?: String;
  imgUrl_not?: String;
  imgUrl_in?: String[] | String;
  imgUrl_not_in?: String[] | String;
  imgUrl_lt?: String;
  imgUrl_lte?: String;
  imgUrl_gt?: String;
  imgUrl_gte?: String;
  imgUrl_contains?: String;
  imgUrl_not_contains?: String;
  imgUrl_starts_with?: String;
  imgUrl_not_starts_with?: String;
  imgUrl_ends_with?: String;
  imgUrl_not_ends_with?: String;
  team?: TeamWhereInput;
  captain?: Boolean;
  captain_not?: Boolean;
  personalInfo?: PersonalInfoWhereInput;
  position?: PlayerPosition;
  position_not?: PlayerPosition;
  position_in?: PlayerPosition[] | PlayerPosition;
  position_not_in?: PlayerPosition[] | PlayerPosition;
  altPosition?: PlayerPosition;
  altPosition_not?: PlayerPosition;
  altPosition_in?: PlayerPosition[] | PlayerPosition;
  altPosition_not_in?: PlayerPosition[] | PlayerPosition;
  assessment?: AssessmentWhereInput;
  foot?: Foot;
  foot_not?: Foot;
  foot_in?: Foot[] | Foot;
  foot_not_in?: Foot[] | Foot;
  from?: WhereFromWhereInput;
  injured?: Boolean;
  injured_not?: Boolean;
  injury_some?: InjuryWhereInput;
  sizes?: SizeWhereInput;
  goals_some?: GoalWhereInput;
  assist_some?: AssistWhereInput;
  bookings_some?: BookingWhereInput;
  lineup_some?: MatchWhereInput;
  bench_some?: MatchWhereInput;
  AND?: PlayerWhereInput[] | PlayerWhereInput;
}

export interface TeamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  logoUrl?: String;
  logoUrl_not?: String;
  logoUrl_in?: String[] | String;
  logoUrl_not_in?: String[] | String;
  logoUrl_lt?: String;
  logoUrl_lte?: String;
  logoUrl_gt?: String;
  logoUrl_gte?: String;
  logoUrl_contains?: String;
  logoUrl_not_contains?: String;
  logoUrl_starts_with?: String;
  logoUrl_not_starts_with?: String;
  logoUrl_ends_with?: String;
  logoUrl_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  players_some?: PlayerWhereInput;
  staff_some?: StaffWhereInput;
  AND?: TeamWhereInput[] | TeamWhereInput;
}

export interface StaffWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nick?: String;
  nick_not?: String;
  nick_in?: String[] | String;
  nick_not_in?: String[] | String;
  nick_lt?: String;
  nick_lte?: String;
  nick_gt?: String;
  nick_gte?: String;
  nick_contains?: String;
  nick_not_contains?: String;
  nick_starts_with?: String;
  nick_not_starts_with?: String;
  nick_ends_with?: String;
  nick_not_ends_with?: String;
  imgUrl?: String;
  imgUrl_not?: String;
  imgUrl_in?: String[] | String;
  imgUrl_not_in?: String[] | String;
  imgUrl_lt?: String;
  imgUrl_lte?: String;
  imgUrl_gt?: String;
  imgUrl_gte?: String;
  imgUrl_contains?: String;
  imgUrl_not_contains?: String;
  imgUrl_starts_with?: String;
  imgUrl_not_starts_with?: String;
  imgUrl_ends_with?: String;
  imgUrl_not_ends_with?: String;
  team?: TeamWhereInput;
  personalInfo?: StaffInfoWhereInput;
  from?: StaffFromWhereInput;
  sizes?: StaffSizeWhereInput;
  role?: String;
  role_not?: String;
  role_in?: String[] | String;
  role_not_in?: String[] | String;
  role_lt?: String;
  role_lte?: String;
  role_gt?: String;
  role_gte?: String;
  role_contains?: String;
  role_not_contains?: String;
  role_starts_with?: String;
  role_not_starts_with?: String;
  role_ends_with?: String;
  role_not_ends_with?: String;
  matches_some?: MatchWhereInput;
  AND?: StaffWhereInput[] | StaffWhereInput;
}

export interface StaffInfoWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  dateOfBirth?: DateTimeInput;
  dateOfBirth_not?: DateTimeInput;
  dateOfBirth_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_not_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_lt?: DateTimeInput;
  dateOfBirth_lte?: DateTimeInput;
  dateOfBirth_gt?: DateTimeInput;
  dateOfBirth_gte?: DateTimeInput;
  tel?: Int;
  tel_not?: Int;
  tel_in?: Int[] | Int;
  tel_not_in?: Int[] | Int;
  tel_lt?: Int;
  tel_lte?: Int;
  tel_gt?: Int;
  tel_gte?: Int;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  dni?: String;
  dni_not?: String;
  dni_in?: String[] | String;
  dni_not_in?: String[] | String;
  dni_lt?: String;
  dni_lte?: String;
  dni_gt?: String;
  dni_gte?: String;
  dni_contains?: String;
  dni_not_contains?: String;
  dni_starts_with?: String;
  dni_not_starts_with?: String;
  dni_ends_with?: String;
  dni_not_ends_with?: String;
  AND?: StaffInfoWhereInput[] | StaffInfoWhereInput;
}

export interface StaffFromWhereInput {
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  number?: Int;
  number_not?: Int;
  number_in?: Int[] | Int;
  number_not_in?: Int[] | Int;
  number_lt?: Int;
  number_lte?: Int;
  number_gt?: Int;
  number_gte?: Int;
  town?: String;
  town_not?: String;
  town_in?: String[] | String;
  town_not_in?: String[] | String;
  town_lt?: String;
  town_lte?: String;
  town_gt?: String;
  town_gte?: String;
  town_contains?: String;
  town_not_contains?: String;
  town_starts_with?: String;
  town_not_starts_with?: String;
  town_ends_with?: String;
  town_not_ends_with?: String;
  province?: String;
  province_not?: String;
  province_in?: String[] | String;
  province_not_in?: String[] | String;
  province_lt?: String;
  province_lte?: String;
  province_gt?: String;
  province_gte?: String;
  province_contains?: String;
  province_not_contains?: String;
  province_starts_with?: String;
  province_not_starts_with?: String;
  province_ends_with?: String;
  province_not_ends_with?: String;
  countruy?: String;
  countruy_not?: String;
  countruy_in?: String[] | String;
  countruy_not_in?: String[] | String;
  countruy_lt?: String;
  countruy_lte?: String;
  countruy_gt?: String;
  countruy_gte?: String;
  countruy_contains?: String;
  countruy_not_contains?: String;
  countruy_starts_with?: String;
  countruy_not_starts_with?: String;
  countruy_ends_with?: String;
  countruy_not_ends_with?: String;
  PC?: Int;
  PC_not?: Int;
  PC_in?: Int[] | Int;
  PC_not_in?: Int[] | Int;
  PC_lt?: Int;
  PC_lte?: Int;
  PC_gt?: Int;
  PC_gte?: Int;
  AND?: StaffFromWhereInput[] | StaffFromWhereInput;
}

export interface StaffSizeWhereInput {
  clothing?: String;
  clothing_not?: String;
  clothing_in?: String[] | String;
  clothing_not_in?: String[] | String;
  clothing_lt?: String;
  clothing_lte?: String;
  clothing_gt?: String;
  clothing_gte?: String;
  clothing_contains?: String;
  clothing_not_contains?: String;
  clothing_starts_with?: String;
  clothing_not_starts_with?: String;
  clothing_ends_with?: String;
  clothing_not_ends_with?: String;
  step?: Int;
  step_not?: Int;
  step_in?: Int[] | Int;
  step_not_in?: Int[] | Int;
  step_lt?: Int;
  step_lte?: Int;
  step_gt?: Int;
  step_gte?: Int;
  AND?: StaffSizeWhereInput[] | StaffSizeWhereInput;
}

export interface MatchWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  jornada?: Int;
  jornada_not?: Int;
  jornada_in?: Int[] | Int;
  jornada_not_in?: Int[] | Int;
  jornada_lt?: Int;
  jornada_lte?: Int;
  jornada_gt?: Int;
  jornada_gte?: Int;
  finished?: Boolean;
  finished_not?: Boolean;
  homeTeam?: Boolean;
  homeTeam_not?: Boolean;
  opponent?: TeamWhereInput;
  win?: Boolean;
  win_not?: Boolean;
  competition?: Competiton;
  competition_not?: Competiton;
  competition_in?: Competiton[] | Competiton;
  competition_not_in?: Competiton[] | Competiton;
  captain?: PlayerWhereInput;
  staff_some?: StaffWhereInput;
  lineup_some?: PlayerWhereInput;
  bench_some?: PlayerWhereInput;
  score?: ScoreWhereInput;
  goals_some?: GoalWhereInput;
  assist_some?: AssistWhereInput;
  substitutions_some?: SubstitutionsWhereInput;
  substitutions_every?: SubstitutionsRestrictedWhereInput;
  substitutions_none?: SubstitutionsRestrictedWhereInput;
  bookings_some?: BookingWhereInput;
  referees?: String;
  referees_not?: String;
  referees_in?: String[] | String;
  referees_not_in?: String[] | String;
  referees_lt?: String;
  referees_lte?: String;
  referees_gt?: String;
  referees_gte?: String;
  referees_contains?: String;
  referees_not_contains?: String;
  referees_starts_with?: String;
  referees_not_starts_with?: String;
  referees_ends_with?: String;
  referees_not_ends_with?: String;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: MatchWhereInput[] | MatchWhereInput;
}

export interface ScoreWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  fullTime?: HomeAndAwayWhereInput;
  halfTime?: HomeAndAwayWhereInput;
  extraTime?: HomeAndAwayWhereInput;
  penalties?: HomeAndAwayWhereInput;
  AND?: ScoreWhereInput[] | ScoreWhereInput;
}

export interface HomeAndAwayWhereInput {
  homeTeam?: Int;
  homeTeam_not?: Int;
  homeTeam_in?: Int[] | Int;
  homeTeam_not_in?: Int[] | Int;
  homeTeam_lt?: Int;
  homeTeam_lte?: Int;
  homeTeam_gt?: Int;
  homeTeam_gte?: Int;
  awayTeam?: Int;
  awayTeam_not?: Int;
  awayTeam_in?: Int[] | Int;
  awayTeam_not_in?: Int[] | Int;
  awayTeam_lt?: Int;
  awayTeam_lte?: Int;
  awayTeam_gt?: Int;
  awayTeam_gte?: Int;
  AND?: HomeAndAwayWhereInput[] | HomeAndAwayWhereInput;
}

export interface GoalWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  player?: PlayerWhereInput;
  match?: MatchWhereInput;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: GoalWhereInput[] | GoalWhereInput;
}

export interface AssistWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  player?: PlayerWhereInput;
  match?: MatchWhereInput;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: AssistWhereInput[] | AssistWhereInput;
}

export interface SubstitutionsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  playerIn?: PlayerWhereInput;
  playerOut?: PlayerWhereInput;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  AND?: SubstitutionsWhereInput[] | SubstitutionsWhereInput;
}

export interface SubstitutionsRestrictedWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  AND?: SubstitutionsRestrictedWhereInput[] | SubstitutionsRestrictedWhereInput;
}

export interface BookingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  player?: PlayerWhereInput;
  match?: MatchWhereInput;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  card?: ColorCard;
  card_not?: ColorCard;
  card_in?: ColorCard[] | ColorCard;
  card_not_in?: ColorCard[] | ColorCard;
  AND?: BookingWhereInput[] | BookingWhereInput;
}

export interface PersonalInfoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  dateOfBirth?: DateTimeInput;
  dateOfBirth_not?: DateTimeInput;
  dateOfBirth_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_not_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_lt?: DateTimeInput;
  dateOfBirth_lte?: DateTimeInput;
  dateOfBirth_gt?: DateTimeInput;
  dateOfBirth_gte?: DateTimeInput;
  tel?: Int;
  tel_not?: Int;
  tel_in?: Int[] | Int;
  tel_not_in?: Int[] | Int;
  tel_lt?: Int;
  tel_lte?: Int;
  tel_gt?: Int;
  tel_gte?: Int;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  dni?: String;
  dni_not?: String;
  dni_in?: String[] | String;
  dni_not_in?: String[] | String;
  dni_lt?: String;
  dni_lte?: String;
  dni_gt?: String;
  dni_gte?: String;
  dni_contains?: String;
  dni_not_contains?: String;
  dni_starts_with?: String;
  dni_not_starts_with?: String;
  dni_ends_with?: String;
  dni_not_ends_with?: String;
  origin?: String;
  origin_not?: String;
  origin_in?: String[] | String;
  origin_not_in?: String[] | String;
  origin_lt?: String;
  origin_lte?: String;
  origin_gt?: String;
  origin_gte?: String;
  origin_contains?: String;
  origin_not_contains?: String;
  origin_starts_with?: String;
  origin_not_starts_with?: String;
  origin_ends_with?: String;
  origin_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  childs?: Int;
  childs_not?: Int;
  childs_in?: Int[] | Int;
  childs_not_in?: Int[] | Int;
  childs_lt?: Int;
  childs_lte?: Int;
  childs_gt?: Int;
  childs_gte?: Int;
  brothers?: Int;
  brothers_not?: Int;
  brothers_in?: Int[] | Int;
  brothers_not_in?: Int[] | Int;
  brothers_lt?: Int;
  brothers_lte?: Int;
  brothers_gt?: Int;
  brothers_gte?: Int;
  poscBrothers?: Int;
  poscBrothers_not?: Int;
  poscBrothers_in?: Int[] | Int;
  poscBrothers_not_in?: Int[] | Int;
  poscBrothers_lt?: Int;
  poscBrothers_lte?: Int;
  poscBrothers_gt?: Int;
  poscBrothers_gte?: Int;
  clubBrothers?: Int;
  clubBrothers_not?: Int;
  clubBrothers_in?: Int[] | Int;
  clubBrothers_not_in?: Int[] | Int;
  clubBrothers_lt?: Int;
  clubBrothers_lte?: Int;
  clubBrothers_gt?: Int;
  clubBrothers_gte?: Int;
  AND?: PersonalInfoWhereInput[] | PersonalInfoWhereInput;
}

export interface AssessmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  personality?: Float;
  personality_not?: Float;
  personality_in?: Float[] | Float;
  personality_not_in?: Float[] | Float;
  personality_lt?: Float;
  personality_lte?: Float;
  personality_gt?: Float;
  personality_gte?: Float;
  psychology?: Float;
  psychology_not?: Float;
  psychology_in?: Float[] | Float;
  psychology_not_in?: Float[] | Float;
  psychology_lt?: Float;
  psychology_lte?: Float;
  psychology_gt?: Float;
  psychology_gte?: Float;
  technical?: Float;
  technical_not?: Float;
  technical_in?: Float[] | Float;
  technical_not_in?: Float[] | Float;
  technical_lt?: Float;
  technical_lte?: Float;
  technical_gt?: Float;
  technical_gte?: Float;
  tactical?: Float;
  tactical_not?: Float;
  tactical_in?: Float[] | Float;
  tactical_not_in?: Float[] | Float;
  tactical_lt?: Float;
  tactical_lte?: Float;
  tactical_gt?: Float;
  tactical_gte?: Float;
  physical?: Float;
  physical_not?: Float;
  physical_in?: Float[] | Float;
  physical_not_in?: Float[] | Float;
  physical_lt?: Float;
  physical_lte?: Float;
  physical_gt?: Float;
  physical_gte?: Float;
  AND?: AssessmentWhereInput[] | AssessmentWhereInput;
}

export interface WhereFromWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  number?: Int;
  number_not?: Int;
  number_in?: Int[] | Int;
  number_not_in?: Int[] | Int;
  number_lt?: Int;
  number_lte?: Int;
  number_gt?: Int;
  number_gte?: Int;
  town?: String;
  town_not?: String;
  town_in?: String[] | String;
  town_not_in?: String[] | String;
  town_lt?: String;
  town_lte?: String;
  town_gt?: String;
  town_gte?: String;
  town_contains?: String;
  town_not_contains?: String;
  town_starts_with?: String;
  town_not_starts_with?: String;
  town_ends_with?: String;
  town_not_ends_with?: String;
  province?: String;
  province_not?: String;
  province_in?: String[] | String;
  province_not_in?: String[] | String;
  province_lt?: String;
  province_lte?: String;
  province_gt?: String;
  province_gte?: String;
  province_contains?: String;
  province_not_contains?: String;
  province_starts_with?: String;
  province_not_starts_with?: String;
  province_ends_with?: String;
  province_not_ends_with?: String;
  countruy?: String;
  countruy_not?: String;
  countruy_in?: String[] | String;
  countruy_not_in?: String[] | String;
  countruy_lt?: String;
  countruy_lte?: String;
  countruy_gt?: String;
  countruy_gte?: String;
  countruy_contains?: String;
  countruy_not_contains?: String;
  countruy_starts_with?: String;
  countruy_not_starts_with?: String;
  countruy_ends_with?: String;
  countruy_not_ends_with?: String;
  PC?: Int;
  PC_not?: Int;
  PC_in?: Int[] | Int;
  PC_not_in?: Int[] | Int;
  PC_lt?: Int;
  PC_lte?: Int;
  PC_gt?: Int;
  PC_gte?: Int;
  placeOfBirth?: String;
  placeOfBirth_not?: String;
  placeOfBirth_in?: String[] | String;
  placeOfBirth_not_in?: String[] | String;
  placeOfBirth_lt?: String;
  placeOfBirth_lte?: String;
  placeOfBirth_gt?: String;
  placeOfBirth_gte?: String;
  placeOfBirth_contains?: String;
  placeOfBirth_not_contains?: String;
  placeOfBirth_starts_with?: String;
  placeOfBirth_not_starts_with?: String;
  placeOfBirth_ends_with?: String;
  placeOfBirth_not_ends_with?: String;
  nationality?: String;
  nationality_not?: String;
  nationality_in?: String[] | String;
  nationality_not_in?: String[] | String;
  nationality_lt?: String;
  nationality_lte?: String;
  nationality_gt?: String;
  nationality_gte?: String;
  nationality_contains?: String;
  nationality_not_contains?: String;
  nationality_starts_with?: String;
  nationality_not_starts_with?: String;
  nationality_ends_with?: String;
  nationality_not_ends_with?: String;
  extra?: Boolean;
  extra_not?: Boolean;
  AND?: WhereFromWhereInput[] | WhereFromWhereInput;
}

export interface InjuryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startAt?: DateTimeInput;
  startAt_not?: DateTimeInput;
  startAt_in?: DateTimeInput[] | DateTimeInput;
  startAt_not_in?: DateTimeInput[] | DateTimeInput;
  startAt_lt?: DateTimeInput;
  startAt_lte?: DateTimeInput;
  startAt_gt?: DateTimeInput;
  startAt_gte?: DateTimeInput;
  endAt?: DateTimeInput;
  endAt_not?: DateTimeInput;
  endAt_in?: DateTimeInput[] | DateTimeInput;
  endAt_not_in?: DateTimeInput[] | DateTimeInput;
  endAt_lt?: DateTimeInput;
  endAt_lte?: DateTimeInput;
  endAt_gt?: DateTimeInput;
  endAt_gte?: DateTimeInput;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  player?: PlayerWhereInput;
  AND?: InjuryWhereInput[] | InjuryWhereInput;
}

export interface SizeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  clothing?: String;
  clothing_not?: String;
  clothing_in?: String[] | String;
  clothing_not_in?: String[] | String;
  clothing_lt?: String;
  clothing_lte?: String;
  clothing_gt?: String;
  clothing_gte?: String;
  clothing_contains?: String;
  clothing_not_contains?: String;
  clothing_starts_with?: String;
  clothing_not_starts_with?: String;
  clothing_ends_with?: String;
  clothing_not_ends_with?: String;
  step?: Int;
  step_not?: Int;
  step_in?: Int[] | Int;
  step_not_in?: Int[] | Int;
  step_lt?: Int;
  step_lte?: Int;
  step_gt?: Int;
  step_gte?: Int;
  AND?: SizeWhereInput[] | SizeWhereInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GoalWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type InjuryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MatchWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  jornada?: Int;
}>;

export type PlayerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type StaffWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TeamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface AssistCreateInput {
  id?: ID_Input;
  player: PlayerCreateOneWithoutAssistInput;
  match: MatchCreateOneWithoutAssistInput;
  min?: Float;
  desc?: String;
}

export interface PlayerCreateOneWithoutAssistInput {
  create?: PlayerCreateWithoutAssistInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerCreateWithoutAssistInput {
  id?: ID_Input;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  team?: TeamCreateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoCreateOneInput;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentCreateOneInput;
  foot?: Foot;
  from?: WhereFromCreateOneInput;
  injured?: Boolean;
  injury?: InjuryCreateManyWithoutPlayerInput;
  sizes?: SizeCreateOneInput;
  goals?: GoalCreateManyWithoutPlayerInput;
  bookings?: BookingCreateManyWithoutPlayerInput;
  lineup?: MatchCreateManyWithoutLineupInput;
  bench?: MatchCreateManyWithoutBenchInput;
}

export interface TeamCreateOneWithoutPlayersInput {
  create?: TeamCreateWithoutPlayersInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutPlayersInput {
  id?: ID_Input;
  logoUrl?: String;
  name: String;
  staff?: StaffCreateManyWithoutTeamInput;
}

export interface StaffCreateManyWithoutTeamInput {
  create?: StaffCreateWithoutTeamInput[] | StaffCreateWithoutTeamInput;
  connect?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
}

export interface StaffCreateWithoutTeamInput {
  id?: ID_Input;
  nick: String;
  imgUrl?: String;
  personalInfo?: StaffInfoCreateOneInput;
  from?: StaffFromCreateOneInput;
  sizes?: StaffSizeCreateOneInput;
  role?: String;
  matches?: MatchCreateManyWithoutStaffInput;
}

export interface StaffInfoCreateOneInput {
  create?: StaffInfoCreateInput;
}

export interface StaffInfoCreateInput {
  name: String;
  firstName: String;
  lastName?: String;
  dateOfBirth?: DateTimeInput;
  tel?: Int;
  email?: String;
  dni: String;
}

export interface StaffFromCreateOneInput {
  create?: StaffFromCreateInput;
}

export interface StaffFromCreateInput {
  address?: String;
  number?: Int;
  town?: String;
  province?: String;
  countruy?: String;
  PC?: Int;
}

export interface StaffSizeCreateOneInput {
  create?: StaffSizeCreateInput;
}

export interface StaffSizeCreateInput {
  clothing?: String;
  step?: Int;
}

export interface MatchCreateManyWithoutStaffInput {
  create?: MatchCreateWithoutStaffInput[] | MatchCreateWithoutStaffInput;
  connect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
}

export interface MatchCreateWithoutStaffInput {
  id?: ID_Input;
  date?: DateTimeInput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamCreateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain: PlayerCreateOneInput;
  lineup?: PlayerCreateManyWithoutLineupInput;
  bench?: PlayerCreateManyWithoutBenchInput;
  score: ScoreCreateOneInput;
  goals?: GoalCreateManyWithoutMatchInput;
  assist?: AssistCreateManyWithoutMatchInput;
  substitutions?: SubstitutionsCreateManyInput;
  bookings?: BookingCreateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface TeamCreateOneInput {
  create?: TeamCreateInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateInput {
  id?: ID_Input;
  logoUrl?: String;
  name: String;
  players?: PlayerCreateManyWithoutTeamInput;
  staff?: StaffCreateManyWithoutTeamInput;
}

export interface PlayerCreateManyWithoutTeamInput {
  create?: PlayerCreateWithoutTeamInput[] | PlayerCreateWithoutTeamInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
}

export interface PlayerCreateWithoutTeamInput {
  id?: ID_Input;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  captain?: Boolean;
  personalInfo?: PersonalInfoCreateOneInput;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentCreateOneInput;
  foot?: Foot;
  from?: WhereFromCreateOneInput;
  injured?: Boolean;
  injury?: InjuryCreateManyWithoutPlayerInput;
  sizes?: SizeCreateOneInput;
  goals?: GoalCreateManyWithoutPlayerInput;
  assist?: AssistCreateManyWithoutPlayerInput;
  bookings?: BookingCreateManyWithoutPlayerInput;
  lineup?: MatchCreateManyWithoutLineupInput;
  bench?: MatchCreateManyWithoutBenchInput;
}

export interface PersonalInfoCreateOneInput {
  create?: PersonalInfoCreateInput;
}

export interface PersonalInfoCreateInput {
  id?: ID_Input;
  name: String;
  firstName: String;
  lastName?: String;
  dateOfBirth?: DateTimeInput;
  tel?: Int;
  email?: String;
  dni: String;
  origin?: String;
  status?: String;
  childs?: Int;
  brothers?: Int;
  poscBrothers?: Int;
  clubBrothers?: Int;
}

export interface AssessmentCreateOneInput {
  create?: AssessmentCreateInput;
}

export interface AssessmentCreateInput {
  id?: ID_Input;
  personality?: Float;
  psychology?: Float;
  technical?: Float;
  tactical?: Float;
  physical?: Float;
}

export interface WhereFromCreateOneInput {
  create?: WhereFromCreateInput;
}

export interface WhereFromCreateInput {
  id?: ID_Input;
  address?: String;
  number?: Int;
  town?: String;
  province?: String;
  countruy?: String;
  PC?: Int;
  placeOfBirth?: String;
  nationality?: String;
  extra?: Boolean;
}

export interface InjuryCreateManyWithoutPlayerInput {
  create?: InjuryCreateWithoutPlayerInput[] | InjuryCreateWithoutPlayerInput;
  connect?: InjuryWhereUniqueInput[] | InjuryWhereUniqueInput;
}

export interface InjuryCreateWithoutPlayerInput {
  id?: ID_Input;
  startAt: DateTimeInput;
  endAt?: DateTimeInput;
  desc: String;
}

export interface SizeCreateOneInput {
  create?: SizeCreateInput;
}

export interface SizeCreateInput {
  id?: ID_Input;
  clothing?: String;
  step?: Int;
}

export interface GoalCreateManyWithoutPlayerInput {
  create?: GoalCreateWithoutPlayerInput[] | GoalCreateWithoutPlayerInput;
  connect?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
}

export interface GoalCreateWithoutPlayerInput {
  id?: ID_Input;
  match: MatchCreateOneWithoutGoalsInput;
  min?: Float;
  desc?: String;
}

export interface MatchCreateOneWithoutGoalsInput {
  create?: MatchCreateWithoutGoalsInput;
  connect?: MatchWhereUniqueInput;
}

export interface MatchCreateWithoutGoalsInput {
  id?: ID_Input;
  date?: DateTimeInput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamCreateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain: PlayerCreateOneInput;
  staff?: StaffCreateManyWithoutMatchesInput;
  lineup?: PlayerCreateManyWithoutLineupInput;
  bench?: PlayerCreateManyWithoutBenchInput;
  score: ScoreCreateOneInput;
  assist?: AssistCreateManyWithoutMatchInput;
  substitutions?: SubstitutionsCreateManyInput;
  bookings?: BookingCreateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface PlayerCreateOneInput {
  create?: PlayerCreateInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerCreateInput {
  id?: ID_Input;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  team?: TeamCreateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoCreateOneInput;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentCreateOneInput;
  foot?: Foot;
  from?: WhereFromCreateOneInput;
  injured?: Boolean;
  injury?: InjuryCreateManyWithoutPlayerInput;
  sizes?: SizeCreateOneInput;
  goals?: GoalCreateManyWithoutPlayerInput;
  assist?: AssistCreateManyWithoutPlayerInput;
  bookings?: BookingCreateManyWithoutPlayerInput;
  lineup?: MatchCreateManyWithoutLineupInput;
  bench?: MatchCreateManyWithoutBenchInput;
}

export interface AssistCreateManyWithoutPlayerInput {
  create?: AssistCreateWithoutPlayerInput[] | AssistCreateWithoutPlayerInput;
  connect?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
}

export interface AssistCreateWithoutPlayerInput {
  id?: ID_Input;
  match: MatchCreateOneWithoutAssistInput;
  min?: Float;
  desc?: String;
}

export interface MatchCreateOneWithoutAssistInput {
  create?: MatchCreateWithoutAssistInput;
  connect?: MatchWhereUniqueInput;
}

export interface MatchCreateWithoutAssistInput {
  id?: ID_Input;
  date?: DateTimeInput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamCreateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain: PlayerCreateOneInput;
  staff?: StaffCreateManyWithoutMatchesInput;
  lineup?: PlayerCreateManyWithoutLineupInput;
  bench?: PlayerCreateManyWithoutBenchInput;
  score: ScoreCreateOneInput;
  goals?: GoalCreateManyWithoutMatchInput;
  substitutions?: SubstitutionsCreateManyInput;
  bookings?: BookingCreateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface StaffCreateManyWithoutMatchesInput {
  create?: StaffCreateWithoutMatchesInput[] | StaffCreateWithoutMatchesInput;
  connect?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
}

export interface StaffCreateWithoutMatchesInput {
  id?: ID_Input;
  nick: String;
  imgUrl?: String;
  team?: TeamCreateOneWithoutStaffInput;
  personalInfo?: StaffInfoCreateOneInput;
  from?: StaffFromCreateOneInput;
  sizes?: StaffSizeCreateOneInput;
  role?: String;
}

export interface TeamCreateOneWithoutStaffInput {
  create?: TeamCreateWithoutStaffInput;
  connect?: TeamWhereUniqueInput;
}

export interface TeamCreateWithoutStaffInput {
  id?: ID_Input;
  logoUrl?: String;
  name: String;
  players?: PlayerCreateManyWithoutTeamInput;
}

export interface PlayerCreateManyWithoutLineupInput {
  create?: PlayerCreateWithoutLineupInput[] | PlayerCreateWithoutLineupInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
}

export interface PlayerCreateWithoutLineupInput {
  id?: ID_Input;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  team?: TeamCreateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoCreateOneInput;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentCreateOneInput;
  foot?: Foot;
  from?: WhereFromCreateOneInput;
  injured?: Boolean;
  injury?: InjuryCreateManyWithoutPlayerInput;
  sizes?: SizeCreateOneInput;
  goals?: GoalCreateManyWithoutPlayerInput;
  assist?: AssistCreateManyWithoutPlayerInput;
  bookings?: BookingCreateManyWithoutPlayerInput;
  bench?: MatchCreateManyWithoutBenchInput;
}

export interface BookingCreateManyWithoutPlayerInput {
  create?: BookingCreateWithoutPlayerInput[] | BookingCreateWithoutPlayerInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface BookingCreateWithoutPlayerInput {
  id?: ID_Input;
  match: MatchCreateOneWithoutBookingsInput;
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface MatchCreateOneWithoutBookingsInput {
  create?: MatchCreateWithoutBookingsInput;
  connect?: MatchWhereUniqueInput;
}

export interface MatchCreateWithoutBookingsInput {
  id?: ID_Input;
  date?: DateTimeInput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamCreateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain: PlayerCreateOneInput;
  staff?: StaffCreateManyWithoutMatchesInput;
  lineup?: PlayerCreateManyWithoutLineupInput;
  bench?: PlayerCreateManyWithoutBenchInput;
  score: ScoreCreateOneInput;
  goals?: GoalCreateManyWithoutMatchInput;
  assist?: AssistCreateManyWithoutMatchInput;
  substitutions?: SubstitutionsCreateManyInput;
  referees?: String;
  desc?: String;
}

export interface PlayerCreateManyWithoutBenchInput {
  create?: PlayerCreateWithoutBenchInput[] | PlayerCreateWithoutBenchInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
}

export interface PlayerCreateWithoutBenchInput {
  id?: ID_Input;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  team?: TeamCreateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoCreateOneInput;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentCreateOneInput;
  foot?: Foot;
  from?: WhereFromCreateOneInput;
  injured?: Boolean;
  injury?: InjuryCreateManyWithoutPlayerInput;
  sizes?: SizeCreateOneInput;
  goals?: GoalCreateManyWithoutPlayerInput;
  assist?: AssistCreateManyWithoutPlayerInput;
  bookings?: BookingCreateManyWithoutPlayerInput;
  lineup?: MatchCreateManyWithoutLineupInput;
}

export interface MatchCreateManyWithoutLineupInput {
  create?: MatchCreateWithoutLineupInput[] | MatchCreateWithoutLineupInput;
  connect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
}

export interface MatchCreateWithoutLineupInput {
  id?: ID_Input;
  date?: DateTimeInput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamCreateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain: PlayerCreateOneInput;
  staff?: StaffCreateManyWithoutMatchesInput;
  bench?: PlayerCreateManyWithoutBenchInput;
  score: ScoreCreateOneInput;
  goals?: GoalCreateManyWithoutMatchInput;
  assist?: AssistCreateManyWithoutMatchInput;
  substitutions?: SubstitutionsCreateManyInput;
  bookings?: BookingCreateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface ScoreCreateOneInput {
  create?: ScoreCreateInput;
}

export interface ScoreCreateInput {
  id?: ID_Input;
  fullTime: HomeAndAwayCreateOneInput;
  halfTime?: HomeAndAwayCreateOneInput;
  extraTime?: HomeAndAwayCreateOneInput;
  penalties?: HomeAndAwayCreateOneInput;
}

export interface HomeAndAwayCreateOneInput {
  create?: HomeAndAwayCreateInput;
}

export interface HomeAndAwayCreateInput {
  homeTeam?: Int;
  awayTeam?: Int;
}

export interface GoalCreateManyWithoutMatchInput {
  create?: GoalCreateWithoutMatchInput[] | GoalCreateWithoutMatchInput;
  connect?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
}

export interface GoalCreateWithoutMatchInput {
  id?: ID_Input;
  player: PlayerCreateOneWithoutGoalsInput;
  min?: Float;
  desc?: String;
}

export interface PlayerCreateOneWithoutGoalsInput {
  create?: PlayerCreateWithoutGoalsInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerCreateWithoutGoalsInput {
  id?: ID_Input;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  team?: TeamCreateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoCreateOneInput;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentCreateOneInput;
  foot?: Foot;
  from?: WhereFromCreateOneInput;
  injured?: Boolean;
  injury?: InjuryCreateManyWithoutPlayerInput;
  sizes?: SizeCreateOneInput;
  assist?: AssistCreateManyWithoutPlayerInput;
  bookings?: BookingCreateManyWithoutPlayerInput;
  lineup?: MatchCreateManyWithoutLineupInput;
  bench?: MatchCreateManyWithoutBenchInput;
}

export interface MatchCreateManyWithoutBenchInput {
  create?: MatchCreateWithoutBenchInput[] | MatchCreateWithoutBenchInput;
  connect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
}

export interface MatchCreateWithoutBenchInput {
  id?: ID_Input;
  date?: DateTimeInput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamCreateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain: PlayerCreateOneInput;
  staff?: StaffCreateManyWithoutMatchesInput;
  lineup?: PlayerCreateManyWithoutLineupInput;
  score: ScoreCreateOneInput;
  goals?: GoalCreateManyWithoutMatchInput;
  assist?: AssistCreateManyWithoutMatchInput;
  substitutions?: SubstitutionsCreateManyInput;
  bookings?: BookingCreateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface AssistCreateManyWithoutMatchInput {
  create?: AssistCreateWithoutMatchInput[] | AssistCreateWithoutMatchInput;
  connect?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
}

export interface AssistCreateWithoutMatchInput {
  id?: ID_Input;
  player: PlayerCreateOneWithoutAssistInput;
  min?: Float;
  desc?: String;
}

export interface SubstitutionsCreateManyInput {
  create?: SubstitutionsCreateInput[] | SubstitutionsCreateInput;
}

export interface SubstitutionsCreateInput {
  id?: ID_Input;
  playerIn: PlayerCreateOneInput;
  playerOut: PlayerCreateOneInput;
  min?: Float;
}

export interface BookingCreateManyWithoutMatchInput {
  create?: BookingCreateWithoutMatchInput[] | BookingCreateWithoutMatchInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface BookingCreateWithoutMatchInput {
  id?: ID_Input;
  player: PlayerCreateOneWithoutBookingsInput;
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface PlayerCreateOneWithoutBookingsInput {
  create?: PlayerCreateWithoutBookingsInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerCreateWithoutBookingsInput {
  id?: ID_Input;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  team?: TeamCreateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoCreateOneInput;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentCreateOneInput;
  foot?: Foot;
  from?: WhereFromCreateOneInput;
  injured?: Boolean;
  injury?: InjuryCreateManyWithoutPlayerInput;
  sizes?: SizeCreateOneInput;
  goals?: GoalCreateManyWithoutPlayerInput;
  assist?: AssistCreateManyWithoutPlayerInput;
  lineup?: MatchCreateManyWithoutLineupInput;
  bench?: MatchCreateManyWithoutBenchInput;
}

export interface AssistUpdateInput {
  player?: PlayerUpdateOneRequiredWithoutAssistInput;
  match?: MatchUpdateOneRequiredWithoutAssistInput;
  min?: Float;
  desc?: String;
}

export interface PlayerUpdateOneRequiredWithoutAssistInput {
  create?: PlayerCreateWithoutAssistInput;
  update?: PlayerUpdateWithoutAssistDataInput;
  upsert?: PlayerUpsertWithoutAssistInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerUpdateWithoutAssistDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  injury?: InjuryUpdateManyWithoutPlayerInput;
  sizes?: SizeUpdateOneInput;
  goals?: GoalUpdateManyWithoutPlayerInput;
  bookings?: BookingUpdateManyWithoutPlayerInput;
  lineup?: MatchUpdateManyWithoutLineupInput;
  bench?: MatchUpdateManyWithoutBenchInput;
}

export interface TeamUpdateOneWithoutPlayersInput {
  create?: TeamCreateWithoutPlayersInput;
  update?: TeamUpdateWithoutPlayersDataInput;
  upsert?: TeamUpsertWithoutPlayersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutPlayersDataInput {
  logoUrl?: String;
  name?: String;
  staff?: StaffUpdateManyWithoutTeamInput;
}

export interface StaffUpdateManyWithoutTeamInput {
  create?: StaffCreateWithoutTeamInput[] | StaffCreateWithoutTeamInput;
  delete?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
  connect?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
  set?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
  disconnect?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
  update?:
    | StaffUpdateWithWhereUniqueWithoutTeamInput[]
    | StaffUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | StaffUpsertWithWhereUniqueWithoutTeamInput[]
    | StaffUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: StaffScalarWhereInput[] | StaffScalarWhereInput;
  updateMany?:
    | StaffUpdateManyWithWhereNestedInput[]
    | StaffUpdateManyWithWhereNestedInput;
}

export interface StaffUpdateWithWhereUniqueWithoutTeamInput {
  where: StaffWhereUniqueInput;
  data: StaffUpdateWithoutTeamDataInput;
}

export interface StaffUpdateWithoutTeamDataInput {
  nick?: String;
  imgUrl?: String;
  personalInfo?: StaffInfoUpdateOneInput;
  from?: StaffFromUpdateOneInput;
  sizes?: StaffSizeUpdateOneInput;
  role?: String;
  matches?: MatchUpdateManyWithoutStaffInput;
}

export interface StaffInfoUpdateOneInput {
  create?: StaffInfoCreateInput;
  update?: StaffInfoUpdateDataInput;
  upsert?: StaffInfoUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface StaffInfoUpdateDataInput {
  name?: String;
  firstName?: String;
  lastName?: String;
  dateOfBirth?: DateTimeInput;
  tel?: Int;
  email?: String;
  dni?: String;
}

export interface StaffInfoUpsertNestedInput {
  update: StaffInfoUpdateDataInput;
  create: StaffInfoCreateInput;
}

export interface StaffFromUpdateOneInput {
  create?: StaffFromCreateInput;
  update?: StaffFromUpdateDataInput;
  upsert?: StaffFromUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface StaffFromUpdateDataInput {
  address?: String;
  number?: Int;
  town?: String;
  province?: String;
  countruy?: String;
  PC?: Int;
}

export interface StaffFromUpsertNestedInput {
  update: StaffFromUpdateDataInput;
  create: StaffFromCreateInput;
}

export interface StaffSizeUpdateOneInput {
  create?: StaffSizeCreateInput;
  update?: StaffSizeUpdateDataInput;
  upsert?: StaffSizeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface StaffSizeUpdateDataInput {
  clothing?: String;
  step?: Int;
}

export interface StaffSizeUpsertNestedInput {
  update: StaffSizeUpdateDataInput;
  create: StaffSizeCreateInput;
}

export interface MatchUpdateManyWithoutStaffInput {
  create?: MatchCreateWithoutStaffInput[] | MatchCreateWithoutStaffInput;
  delete?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  connect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  set?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  disconnect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  update?:
    | MatchUpdateWithWhereUniqueWithoutStaffInput[]
    | MatchUpdateWithWhereUniqueWithoutStaffInput;
  upsert?:
    | MatchUpsertWithWhereUniqueWithoutStaffInput[]
    | MatchUpsertWithWhereUniqueWithoutStaffInput;
  deleteMany?: MatchScalarWhereInput[] | MatchScalarWhereInput;
  updateMany?:
    | MatchUpdateManyWithWhereNestedInput[]
    | MatchUpdateManyWithWhereNestedInput;
}

export interface MatchUpdateWithWhereUniqueWithoutStaffInput {
  where: MatchWhereUniqueInput;
  data: MatchUpdateWithoutStaffDataInput;
}

export interface MatchUpdateWithoutStaffDataInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamUpdateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain?: PlayerUpdateOneRequiredInput;
  lineup?: PlayerUpdateManyWithoutLineupInput;
  bench?: PlayerUpdateManyWithoutBenchInput;
  score?: ScoreUpdateOneRequiredInput;
  goals?: GoalUpdateManyWithoutMatchInput;
  assist?: AssistUpdateManyWithoutMatchInput;
  substitutions?: SubstitutionsUpdateManyInput;
  bookings?: BookingUpdateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface TeamUpdateOneInput {
  create?: TeamCreateInput;
  update?: TeamUpdateDataInput;
  upsert?: TeamUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateDataInput {
  logoUrl?: String;
  name?: String;
  players?: PlayerUpdateManyWithoutTeamInput;
  staff?: StaffUpdateManyWithoutTeamInput;
}

export interface PlayerUpdateManyWithoutTeamInput {
  create?: PlayerCreateWithoutTeamInput[] | PlayerCreateWithoutTeamInput;
  delete?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  set?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  disconnect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  update?:
    | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    | PlayerUpdateWithWhereUniqueWithoutTeamInput;
  upsert?:
    | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    | PlayerUpsertWithWhereUniqueWithoutTeamInput;
  deleteMany?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  updateMany?:
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput;
}

export interface PlayerUpdateWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutTeamDataInput;
}

export interface PlayerUpdateWithoutTeamDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  injury?: InjuryUpdateManyWithoutPlayerInput;
  sizes?: SizeUpdateOneInput;
  goals?: GoalUpdateManyWithoutPlayerInput;
  assist?: AssistUpdateManyWithoutPlayerInput;
  bookings?: BookingUpdateManyWithoutPlayerInput;
  lineup?: MatchUpdateManyWithoutLineupInput;
  bench?: MatchUpdateManyWithoutBenchInput;
}

export interface PersonalInfoUpdateOneInput {
  create?: PersonalInfoCreateInput;
  update?: PersonalInfoUpdateDataInput;
  upsert?: PersonalInfoUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PersonalInfoWhereUniqueInput;
}

export interface PersonalInfoUpdateDataInput {
  name?: String;
  firstName?: String;
  lastName?: String;
  dateOfBirth?: DateTimeInput;
  tel?: Int;
  email?: String;
  dni?: String;
  origin?: String;
  status?: String;
  childs?: Int;
  brothers?: Int;
  poscBrothers?: Int;
  clubBrothers?: Int;
}

export interface PersonalInfoUpsertNestedInput {
  update: PersonalInfoUpdateDataInput;
  create: PersonalInfoCreateInput;
}

export type PersonalInfoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AssessmentUpdateOneInput {
  create?: AssessmentCreateInput;
  update?: AssessmentUpdateDataInput;
  upsert?: AssessmentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AssessmentWhereUniqueInput;
}

export interface AssessmentUpdateDataInput {
  personality?: Float;
  psychology?: Float;
  technical?: Float;
  tactical?: Float;
  physical?: Float;
}

export interface AssessmentUpsertNestedInput {
  update: AssessmentUpdateDataInput;
  create: AssessmentCreateInput;
}

export type AssessmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface WhereFromUpdateOneInput {
  create?: WhereFromCreateInput;
  update?: WhereFromUpdateDataInput;
  upsert?: WhereFromUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WhereFromWhereUniqueInput;
}

export interface WhereFromUpdateDataInput {
  address?: String;
  number?: Int;
  town?: String;
  province?: String;
  countruy?: String;
  PC?: Int;
  placeOfBirth?: String;
  nationality?: String;
  extra?: Boolean;
}

export interface WhereFromUpsertNestedInput {
  update: WhereFromUpdateDataInput;
  create: WhereFromCreateInput;
}

export type WhereFromWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InjuryUpdateManyWithoutPlayerInput {
  create?: InjuryCreateWithoutPlayerInput[] | InjuryCreateWithoutPlayerInput;
  delete?: InjuryWhereUniqueInput[] | InjuryWhereUniqueInput;
  connect?: InjuryWhereUniqueInput[] | InjuryWhereUniqueInput;
  set?: InjuryWhereUniqueInput[] | InjuryWhereUniqueInput;
  disconnect?: InjuryWhereUniqueInput[] | InjuryWhereUniqueInput;
  update?:
    | InjuryUpdateWithWhereUniqueWithoutPlayerInput[]
    | InjuryUpdateWithWhereUniqueWithoutPlayerInput;
  upsert?:
    | InjuryUpsertWithWhereUniqueWithoutPlayerInput[]
    | InjuryUpsertWithWhereUniqueWithoutPlayerInput;
  deleteMany?: InjuryScalarWhereInput[] | InjuryScalarWhereInput;
  updateMany?:
    | InjuryUpdateManyWithWhereNestedInput[]
    | InjuryUpdateManyWithWhereNestedInput;
}

export interface InjuryUpdateWithWhereUniqueWithoutPlayerInput {
  where: InjuryWhereUniqueInput;
  data: InjuryUpdateWithoutPlayerDataInput;
}

export interface InjuryUpdateWithoutPlayerDataInput {
  startAt?: DateTimeInput;
  endAt?: DateTimeInput;
  desc?: String;
}

export interface InjuryUpsertWithWhereUniqueWithoutPlayerInput {
  where: InjuryWhereUniqueInput;
  update: InjuryUpdateWithoutPlayerDataInput;
  create: InjuryCreateWithoutPlayerInput;
}

export interface InjuryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startAt?: DateTimeInput;
  startAt_not?: DateTimeInput;
  startAt_in?: DateTimeInput[] | DateTimeInput;
  startAt_not_in?: DateTimeInput[] | DateTimeInput;
  startAt_lt?: DateTimeInput;
  startAt_lte?: DateTimeInput;
  startAt_gt?: DateTimeInput;
  startAt_gte?: DateTimeInput;
  endAt?: DateTimeInput;
  endAt_not?: DateTimeInput;
  endAt_in?: DateTimeInput[] | DateTimeInput;
  endAt_not_in?: DateTimeInput[] | DateTimeInput;
  endAt_lt?: DateTimeInput;
  endAt_lte?: DateTimeInput;
  endAt_gt?: DateTimeInput;
  endAt_gte?: DateTimeInput;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: InjuryScalarWhereInput[] | InjuryScalarWhereInput;
  OR?: InjuryScalarWhereInput[] | InjuryScalarWhereInput;
  NOT?: InjuryScalarWhereInput[] | InjuryScalarWhereInput;
}

export interface InjuryUpdateManyWithWhereNestedInput {
  where: InjuryScalarWhereInput;
  data: InjuryUpdateManyDataInput;
}

export interface InjuryUpdateManyDataInput {
  startAt?: DateTimeInput;
  endAt?: DateTimeInput;
  desc?: String;
}

export interface SizeUpdateOneInput {
  create?: SizeCreateInput;
  update?: SizeUpdateDataInput;
  upsert?: SizeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SizeWhereUniqueInput;
}

export interface SizeUpdateDataInput {
  clothing?: String;
  step?: Int;
}

export interface SizeUpsertNestedInput {
  update: SizeUpdateDataInput;
  create: SizeCreateInput;
}

export type SizeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GoalUpdateManyWithoutPlayerInput {
  create?: GoalCreateWithoutPlayerInput[] | GoalCreateWithoutPlayerInput;
  delete?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
  connect?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
  set?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
  disconnect?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
  update?:
    | GoalUpdateWithWhereUniqueWithoutPlayerInput[]
    | GoalUpdateWithWhereUniqueWithoutPlayerInput;
  upsert?:
    | GoalUpsertWithWhereUniqueWithoutPlayerInput[]
    | GoalUpsertWithWhereUniqueWithoutPlayerInput;
  deleteMany?: GoalScalarWhereInput[] | GoalScalarWhereInput;
  updateMany?:
    | GoalUpdateManyWithWhereNestedInput[]
    | GoalUpdateManyWithWhereNestedInput;
}

export interface GoalUpdateWithWhereUniqueWithoutPlayerInput {
  where: GoalWhereUniqueInput;
  data: GoalUpdateWithoutPlayerDataInput;
}

export interface GoalUpdateWithoutPlayerDataInput {
  match?: MatchUpdateOneRequiredWithoutGoalsInput;
  min?: Float;
  desc?: String;
}

export interface MatchUpdateOneRequiredWithoutGoalsInput {
  create?: MatchCreateWithoutGoalsInput;
  update?: MatchUpdateWithoutGoalsDataInput;
  upsert?: MatchUpsertWithoutGoalsInput;
  connect?: MatchWhereUniqueInput;
}

export interface MatchUpdateWithoutGoalsDataInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamUpdateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain?: PlayerUpdateOneRequiredInput;
  staff?: StaffUpdateManyWithoutMatchesInput;
  lineup?: PlayerUpdateManyWithoutLineupInput;
  bench?: PlayerUpdateManyWithoutBenchInput;
  score?: ScoreUpdateOneRequiredInput;
  assist?: AssistUpdateManyWithoutMatchInput;
  substitutions?: SubstitutionsUpdateManyInput;
  bookings?: BookingUpdateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface PlayerUpdateOneRequiredInput {
  create?: PlayerCreateInput;
  update?: PlayerUpdateDataInput;
  upsert?: PlayerUpsertNestedInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerUpdateDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  injury?: InjuryUpdateManyWithoutPlayerInput;
  sizes?: SizeUpdateOneInput;
  goals?: GoalUpdateManyWithoutPlayerInput;
  assist?: AssistUpdateManyWithoutPlayerInput;
  bookings?: BookingUpdateManyWithoutPlayerInput;
  lineup?: MatchUpdateManyWithoutLineupInput;
  bench?: MatchUpdateManyWithoutBenchInput;
}

export interface AssistUpdateManyWithoutPlayerInput {
  create?: AssistCreateWithoutPlayerInput[] | AssistCreateWithoutPlayerInput;
  delete?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
  connect?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
  set?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
  disconnect?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
  update?:
    | AssistUpdateWithWhereUniqueWithoutPlayerInput[]
    | AssistUpdateWithWhereUniqueWithoutPlayerInput;
  upsert?:
    | AssistUpsertWithWhereUniqueWithoutPlayerInput[]
    | AssistUpsertWithWhereUniqueWithoutPlayerInput;
  deleteMany?: AssistScalarWhereInput[] | AssistScalarWhereInput;
  updateMany?:
    | AssistUpdateManyWithWhereNestedInput[]
    | AssistUpdateManyWithWhereNestedInput;
}

export interface AssistUpdateWithWhereUniqueWithoutPlayerInput {
  where: AssistWhereUniqueInput;
  data: AssistUpdateWithoutPlayerDataInput;
}

export interface AssistUpdateWithoutPlayerDataInput {
  match?: MatchUpdateOneRequiredWithoutAssistInput;
  min?: Float;
  desc?: String;
}

export interface MatchUpdateOneRequiredWithoutAssistInput {
  create?: MatchCreateWithoutAssistInput;
  update?: MatchUpdateWithoutAssistDataInput;
  upsert?: MatchUpsertWithoutAssistInput;
  connect?: MatchWhereUniqueInput;
}

export interface MatchUpdateWithoutAssistDataInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamUpdateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain?: PlayerUpdateOneRequiredInput;
  staff?: StaffUpdateManyWithoutMatchesInput;
  lineup?: PlayerUpdateManyWithoutLineupInput;
  bench?: PlayerUpdateManyWithoutBenchInput;
  score?: ScoreUpdateOneRequiredInput;
  goals?: GoalUpdateManyWithoutMatchInput;
  substitutions?: SubstitutionsUpdateManyInput;
  bookings?: BookingUpdateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface StaffUpdateManyWithoutMatchesInput {
  create?: StaffCreateWithoutMatchesInput[] | StaffCreateWithoutMatchesInput;
  delete?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
  connect?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
  set?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
  disconnect?: StaffWhereUniqueInput[] | StaffWhereUniqueInput;
  update?:
    | StaffUpdateWithWhereUniqueWithoutMatchesInput[]
    | StaffUpdateWithWhereUniqueWithoutMatchesInput;
  upsert?:
    | StaffUpsertWithWhereUniqueWithoutMatchesInput[]
    | StaffUpsertWithWhereUniqueWithoutMatchesInput;
  deleteMany?: StaffScalarWhereInput[] | StaffScalarWhereInput;
  updateMany?:
    | StaffUpdateManyWithWhereNestedInput[]
    | StaffUpdateManyWithWhereNestedInput;
}

export interface StaffUpdateWithWhereUniqueWithoutMatchesInput {
  where: StaffWhereUniqueInput;
  data: StaffUpdateWithoutMatchesDataInput;
}

export interface StaffUpdateWithoutMatchesDataInput {
  nick?: String;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutStaffInput;
  personalInfo?: StaffInfoUpdateOneInput;
  from?: StaffFromUpdateOneInput;
  sizes?: StaffSizeUpdateOneInput;
  role?: String;
}

export interface TeamUpdateOneWithoutStaffInput {
  create?: TeamCreateWithoutStaffInput;
  update?: TeamUpdateWithoutStaffDataInput;
  upsert?: TeamUpsertWithoutStaffInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TeamWhereUniqueInput;
}

export interface TeamUpdateWithoutStaffDataInput {
  logoUrl?: String;
  name?: String;
  players?: PlayerUpdateManyWithoutTeamInput;
}

export interface TeamUpsertWithoutStaffInput {
  update: TeamUpdateWithoutStaffDataInput;
  create: TeamCreateWithoutStaffInput;
}

export interface StaffUpsertWithWhereUniqueWithoutMatchesInput {
  where: StaffWhereUniqueInput;
  update: StaffUpdateWithoutMatchesDataInput;
  create: StaffCreateWithoutMatchesInput;
}

export interface StaffScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nick?: String;
  nick_not?: String;
  nick_in?: String[] | String;
  nick_not_in?: String[] | String;
  nick_lt?: String;
  nick_lte?: String;
  nick_gt?: String;
  nick_gte?: String;
  nick_contains?: String;
  nick_not_contains?: String;
  nick_starts_with?: String;
  nick_not_starts_with?: String;
  nick_ends_with?: String;
  nick_not_ends_with?: String;
  imgUrl?: String;
  imgUrl_not?: String;
  imgUrl_in?: String[] | String;
  imgUrl_not_in?: String[] | String;
  imgUrl_lt?: String;
  imgUrl_lte?: String;
  imgUrl_gt?: String;
  imgUrl_gte?: String;
  imgUrl_contains?: String;
  imgUrl_not_contains?: String;
  imgUrl_starts_with?: String;
  imgUrl_not_starts_with?: String;
  imgUrl_ends_with?: String;
  imgUrl_not_ends_with?: String;
  role?: String;
  role_not?: String;
  role_in?: String[] | String;
  role_not_in?: String[] | String;
  role_lt?: String;
  role_lte?: String;
  role_gt?: String;
  role_gte?: String;
  role_contains?: String;
  role_not_contains?: String;
  role_starts_with?: String;
  role_not_starts_with?: String;
  role_ends_with?: String;
  role_not_ends_with?: String;
  AND?: StaffScalarWhereInput[] | StaffScalarWhereInput;
  OR?: StaffScalarWhereInput[] | StaffScalarWhereInput;
  NOT?: StaffScalarWhereInput[] | StaffScalarWhereInput;
}

export interface StaffUpdateManyWithWhereNestedInput {
  where: StaffScalarWhereInput;
  data: StaffUpdateManyDataInput;
}

export interface StaffUpdateManyDataInput {
  nick?: String;
  imgUrl?: String;
  role?: String;
}

export interface PlayerUpdateManyWithoutLineupInput {
  create?: PlayerCreateWithoutLineupInput[] | PlayerCreateWithoutLineupInput;
  delete?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  set?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  disconnect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  update?:
    | PlayerUpdateWithWhereUniqueWithoutLineupInput[]
    | PlayerUpdateWithWhereUniqueWithoutLineupInput;
  upsert?:
    | PlayerUpsertWithWhereUniqueWithoutLineupInput[]
    | PlayerUpsertWithWhereUniqueWithoutLineupInput;
  deleteMany?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  updateMany?:
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput;
}

export interface PlayerUpdateWithWhereUniqueWithoutLineupInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutLineupDataInput;
}

export interface PlayerUpdateWithoutLineupDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  injury?: InjuryUpdateManyWithoutPlayerInput;
  sizes?: SizeUpdateOneInput;
  goals?: GoalUpdateManyWithoutPlayerInput;
  assist?: AssistUpdateManyWithoutPlayerInput;
  bookings?: BookingUpdateManyWithoutPlayerInput;
  bench?: MatchUpdateManyWithoutBenchInput;
}

export interface BookingUpdateManyWithoutPlayerInput {
  create?: BookingCreateWithoutPlayerInput[] | BookingCreateWithoutPlayerInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  set?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutPlayerInput[]
    | BookingUpdateWithWhereUniqueWithoutPlayerInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutPlayerInput[]
    | BookingUpsertWithWhereUniqueWithoutPlayerInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface BookingUpdateWithWhereUniqueWithoutPlayerInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutPlayerDataInput;
}

export interface BookingUpdateWithoutPlayerDataInput {
  match?: MatchUpdateOneRequiredWithoutBookingsInput;
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface MatchUpdateOneRequiredWithoutBookingsInput {
  create?: MatchCreateWithoutBookingsInput;
  update?: MatchUpdateWithoutBookingsDataInput;
  upsert?: MatchUpsertWithoutBookingsInput;
  connect?: MatchWhereUniqueInput;
}

export interface MatchUpdateWithoutBookingsDataInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamUpdateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain?: PlayerUpdateOneRequiredInput;
  staff?: StaffUpdateManyWithoutMatchesInput;
  lineup?: PlayerUpdateManyWithoutLineupInput;
  bench?: PlayerUpdateManyWithoutBenchInput;
  score?: ScoreUpdateOneRequiredInput;
  goals?: GoalUpdateManyWithoutMatchInput;
  assist?: AssistUpdateManyWithoutMatchInput;
  substitutions?: SubstitutionsUpdateManyInput;
  referees?: String;
  desc?: String;
}

export interface PlayerUpdateManyWithoutBenchInput {
  create?: PlayerCreateWithoutBenchInput[] | PlayerCreateWithoutBenchInput;
  delete?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  connect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  set?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  disconnect?: PlayerWhereUniqueInput[] | PlayerWhereUniqueInput;
  update?:
    | PlayerUpdateWithWhereUniqueWithoutBenchInput[]
    | PlayerUpdateWithWhereUniqueWithoutBenchInput;
  upsert?:
    | PlayerUpsertWithWhereUniqueWithoutBenchInput[]
    | PlayerUpsertWithWhereUniqueWithoutBenchInput;
  deleteMany?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  updateMany?:
    | PlayerUpdateManyWithWhereNestedInput[]
    | PlayerUpdateManyWithWhereNestedInput;
}

export interface PlayerUpdateWithWhereUniqueWithoutBenchInput {
  where: PlayerWhereUniqueInput;
  data: PlayerUpdateWithoutBenchDataInput;
}

export interface PlayerUpdateWithoutBenchDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  injury?: InjuryUpdateManyWithoutPlayerInput;
  sizes?: SizeUpdateOneInput;
  goals?: GoalUpdateManyWithoutPlayerInput;
  assist?: AssistUpdateManyWithoutPlayerInput;
  bookings?: BookingUpdateManyWithoutPlayerInput;
  lineup?: MatchUpdateManyWithoutLineupInput;
}

export interface MatchUpdateManyWithoutLineupInput {
  create?: MatchCreateWithoutLineupInput[] | MatchCreateWithoutLineupInput;
  delete?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  connect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  set?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  disconnect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  update?:
    | MatchUpdateWithWhereUniqueWithoutLineupInput[]
    | MatchUpdateWithWhereUniqueWithoutLineupInput;
  upsert?:
    | MatchUpsertWithWhereUniqueWithoutLineupInput[]
    | MatchUpsertWithWhereUniqueWithoutLineupInput;
  deleteMany?: MatchScalarWhereInput[] | MatchScalarWhereInput;
  updateMany?:
    | MatchUpdateManyWithWhereNestedInput[]
    | MatchUpdateManyWithWhereNestedInput;
}

export interface MatchUpdateWithWhereUniqueWithoutLineupInput {
  where: MatchWhereUniqueInput;
  data: MatchUpdateWithoutLineupDataInput;
}

export interface MatchUpdateWithoutLineupDataInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamUpdateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain?: PlayerUpdateOneRequiredInput;
  staff?: StaffUpdateManyWithoutMatchesInput;
  bench?: PlayerUpdateManyWithoutBenchInput;
  score?: ScoreUpdateOneRequiredInput;
  goals?: GoalUpdateManyWithoutMatchInput;
  assist?: AssistUpdateManyWithoutMatchInput;
  substitutions?: SubstitutionsUpdateManyInput;
  bookings?: BookingUpdateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface ScoreUpdateOneRequiredInput {
  create?: ScoreCreateInput;
  update?: ScoreUpdateDataInput;
  upsert?: ScoreUpsertNestedInput;
  connect?: ScoreWhereUniqueInput;
}

export interface ScoreUpdateDataInput {
  fullTime?: HomeAndAwayUpdateOneRequiredInput;
  halfTime?: HomeAndAwayUpdateOneInput;
  extraTime?: HomeAndAwayUpdateOneInput;
  penalties?: HomeAndAwayUpdateOneInput;
}

export interface HomeAndAwayUpdateOneRequiredInput {
  create?: HomeAndAwayCreateInput;
  update?: HomeAndAwayUpdateDataInput;
  upsert?: HomeAndAwayUpsertNestedInput;
}

export interface HomeAndAwayUpdateDataInput {
  homeTeam?: Int;
  awayTeam?: Int;
}

export interface HomeAndAwayUpsertNestedInput {
  update: HomeAndAwayUpdateDataInput;
  create: HomeAndAwayCreateInput;
}

export interface HomeAndAwayUpdateOneInput {
  create?: HomeAndAwayCreateInput;
  update?: HomeAndAwayUpdateDataInput;
  upsert?: HomeAndAwayUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface ScoreUpsertNestedInput {
  update: ScoreUpdateDataInput;
  create: ScoreCreateInput;
}

export type ScoreWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GoalUpdateManyWithoutMatchInput {
  create?: GoalCreateWithoutMatchInput[] | GoalCreateWithoutMatchInput;
  delete?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
  connect?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
  set?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
  disconnect?: GoalWhereUniqueInput[] | GoalWhereUniqueInput;
  update?:
    | GoalUpdateWithWhereUniqueWithoutMatchInput[]
    | GoalUpdateWithWhereUniqueWithoutMatchInput;
  upsert?:
    | GoalUpsertWithWhereUniqueWithoutMatchInput[]
    | GoalUpsertWithWhereUniqueWithoutMatchInput;
  deleteMany?: GoalScalarWhereInput[] | GoalScalarWhereInput;
  updateMany?:
    | GoalUpdateManyWithWhereNestedInput[]
    | GoalUpdateManyWithWhereNestedInput;
}

export interface GoalUpdateWithWhereUniqueWithoutMatchInput {
  where: GoalWhereUniqueInput;
  data: GoalUpdateWithoutMatchDataInput;
}

export interface GoalUpdateWithoutMatchDataInput {
  player?: PlayerUpdateOneRequiredWithoutGoalsInput;
  min?: Float;
  desc?: String;
}

export interface PlayerUpdateOneRequiredWithoutGoalsInput {
  create?: PlayerCreateWithoutGoalsInput;
  update?: PlayerUpdateWithoutGoalsDataInput;
  upsert?: PlayerUpsertWithoutGoalsInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerUpdateWithoutGoalsDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  injury?: InjuryUpdateManyWithoutPlayerInput;
  sizes?: SizeUpdateOneInput;
  assist?: AssistUpdateManyWithoutPlayerInput;
  bookings?: BookingUpdateManyWithoutPlayerInput;
  lineup?: MatchUpdateManyWithoutLineupInput;
  bench?: MatchUpdateManyWithoutBenchInput;
}

export interface MatchUpdateManyWithoutBenchInput {
  create?: MatchCreateWithoutBenchInput[] | MatchCreateWithoutBenchInput;
  delete?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  connect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  set?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  disconnect?: MatchWhereUniqueInput[] | MatchWhereUniqueInput;
  update?:
    | MatchUpdateWithWhereUniqueWithoutBenchInput[]
    | MatchUpdateWithWhereUniqueWithoutBenchInput;
  upsert?:
    | MatchUpsertWithWhereUniqueWithoutBenchInput[]
    | MatchUpsertWithWhereUniqueWithoutBenchInput;
  deleteMany?: MatchScalarWhereInput[] | MatchScalarWhereInput;
  updateMany?:
    | MatchUpdateManyWithWhereNestedInput[]
    | MatchUpdateManyWithWhereNestedInput;
}

export interface MatchUpdateWithWhereUniqueWithoutBenchInput {
  where: MatchWhereUniqueInput;
  data: MatchUpdateWithoutBenchDataInput;
}

export interface MatchUpdateWithoutBenchDataInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamUpdateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain?: PlayerUpdateOneRequiredInput;
  staff?: StaffUpdateManyWithoutMatchesInput;
  lineup?: PlayerUpdateManyWithoutLineupInput;
  score?: ScoreUpdateOneRequiredInput;
  goals?: GoalUpdateManyWithoutMatchInput;
  assist?: AssistUpdateManyWithoutMatchInput;
  substitutions?: SubstitutionsUpdateManyInput;
  bookings?: BookingUpdateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface AssistUpdateManyWithoutMatchInput {
  create?: AssistCreateWithoutMatchInput[] | AssistCreateWithoutMatchInput;
  delete?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
  connect?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
  set?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
  disconnect?: AssistWhereUniqueInput[] | AssistWhereUniqueInput;
  update?:
    | AssistUpdateWithWhereUniqueWithoutMatchInput[]
    | AssistUpdateWithWhereUniqueWithoutMatchInput;
  upsert?:
    | AssistUpsertWithWhereUniqueWithoutMatchInput[]
    | AssistUpsertWithWhereUniqueWithoutMatchInput;
  deleteMany?: AssistScalarWhereInput[] | AssistScalarWhereInput;
  updateMany?:
    | AssistUpdateManyWithWhereNestedInput[]
    | AssistUpdateManyWithWhereNestedInput;
}

export interface AssistUpdateWithWhereUniqueWithoutMatchInput {
  where: AssistWhereUniqueInput;
  data: AssistUpdateWithoutMatchDataInput;
}

export interface AssistUpdateWithoutMatchDataInput {
  player?: PlayerUpdateOneRequiredWithoutAssistInput;
  min?: Float;
  desc?: String;
}

export interface AssistUpsertWithWhereUniqueWithoutMatchInput {
  where: AssistWhereUniqueInput;
  update: AssistUpdateWithoutMatchDataInput;
  create: AssistCreateWithoutMatchInput;
}

export interface AssistScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: AssistScalarWhereInput[] | AssistScalarWhereInput;
  OR?: AssistScalarWhereInput[] | AssistScalarWhereInput;
  NOT?: AssistScalarWhereInput[] | AssistScalarWhereInput;
}

export interface AssistUpdateManyWithWhereNestedInput {
  where: AssistScalarWhereInput;
  data: AssistUpdateManyDataInput;
}

export interface AssistUpdateManyDataInput {
  min?: Float;
  desc?: String;
}

export interface SubstitutionsUpdateManyInput {
  create?: SubstitutionsCreateInput[] | SubstitutionsCreateInput;
  update?:
    | SubstitutionsUpdateWithWhereUniqueNestedInput[]
    | SubstitutionsUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SubstitutionsUpsertWithWhereUniqueNestedInput[]
    | SubstitutionsUpsertWithWhereUniqueNestedInput;
  delete?: SubstitutionsWhereUniqueInput[] | SubstitutionsWhereUniqueInput;
  deleteMany?: SubstitutionsScalarWhereInput[] | SubstitutionsScalarWhereInput;
  updateMany?:
    | SubstitutionsUpdateManyWithWhereNestedInput[]
    | SubstitutionsUpdateManyWithWhereNestedInput;
}

export interface SubstitutionsUpdateWithWhereUniqueNestedInput {
  where: SubstitutionsWhereUniqueInput;
  data: SubstitutionsUpdateDataInput;
}

export type SubstitutionsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubstitutionsUpdateDataInput {
  playerIn?: PlayerUpdateOneRequiredInput;
  playerOut?: PlayerUpdateOneRequiredInput;
  min?: Float;
}

export interface SubstitutionsUpsertWithWhereUniqueNestedInput {
  where: SubstitutionsWhereUniqueInput;
  update: SubstitutionsUpdateDataInput;
  create: SubstitutionsCreateInput;
}

export interface SubstitutionsScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  AND?: SubstitutionsScalarWhereInput[] | SubstitutionsScalarWhereInput;
  OR?: SubstitutionsScalarWhereInput[] | SubstitutionsScalarWhereInput;
  NOT?: SubstitutionsScalarWhereInput[] | SubstitutionsScalarWhereInput;
}

export interface SubstitutionsUpdateManyWithWhereNestedInput {
  where: SubstitutionsScalarWhereInput;
  data: SubstitutionsUpdateManyDataInput;
}

export interface SubstitutionsUpdateManyDataInput {
  min?: Float;
}

export interface BookingUpdateManyWithoutMatchInput {
  create?: BookingCreateWithoutMatchInput[] | BookingCreateWithoutMatchInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  set?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutMatchInput[]
    | BookingUpdateWithWhereUniqueWithoutMatchInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutMatchInput[]
    | BookingUpsertWithWhereUniqueWithoutMatchInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface BookingUpdateWithWhereUniqueWithoutMatchInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutMatchDataInput;
}

export interface BookingUpdateWithoutMatchDataInput {
  player?: PlayerUpdateOneRequiredWithoutBookingsInput;
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface PlayerUpdateOneRequiredWithoutBookingsInput {
  create?: PlayerCreateWithoutBookingsInput;
  update?: PlayerUpdateWithoutBookingsDataInput;
  upsert?: PlayerUpsertWithoutBookingsInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerUpdateWithoutBookingsDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  injury?: InjuryUpdateManyWithoutPlayerInput;
  sizes?: SizeUpdateOneInput;
  goals?: GoalUpdateManyWithoutPlayerInput;
  assist?: AssistUpdateManyWithoutPlayerInput;
  lineup?: MatchUpdateManyWithoutLineupInput;
  bench?: MatchUpdateManyWithoutBenchInput;
}

export interface PlayerUpsertWithoutBookingsInput {
  update: PlayerUpdateWithoutBookingsDataInput;
  create: PlayerCreateWithoutBookingsInput;
}

export interface BookingUpsertWithWhereUniqueWithoutMatchInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutMatchDataInput;
  create: BookingCreateWithoutMatchInput;
}

export interface BookingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  card?: ColorCard;
  card_not?: ColorCard;
  card_in?: ColorCard[] | ColorCard;
  card_not_in?: ColorCard[] | ColorCard;
  AND?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  OR?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  NOT?: BookingScalarWhereInput[] | BookingScalarWhereInput;
}

export interface BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput;
  data: BookingUpdateManyDataInput;
}

export interface BookingUpdateManyDataInput {
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface MatchUpsertWithWhereUniqueWithoutBenchInput {
  where: MatchWhereUniqueInput;
  update: MatchUpdateWithoutBenchDataInput;
  create: MatchCreateWithoutBenchInput;
}

export interface MatchScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  jornada?: Int;
  jornada_not?: Int;
  jornada_in?: Int[] | Int;
  jornada_not_in?: Int[] | Int;
  jornada_lt?: Int;
  jornada_lte?: Int;
  jornada_gt?: Int;
  jornada_gte?: Int;
  finished?: Boolean;
  finished_not?: Boolean;
  homeTeam?: Boolean;
  homeTeam_not?: Boolean;
  win?: Boolean;
  win_not?: Boolean;
  competition?: Competiton;
  competition_not?: Competiton;
  competition_in?: Competiton[] | Competiton;
  competition_not_in?: Competiton[] | Competiton;
  referees?: String;
  referees_not?: String;
  referees_in?: String[] | String;
  referees_not_in?: String[] | String;
  referees_lt?: String;
  referees_lte?: String;
  referees_gt?: String;
  referees_gte?: String;
  referees_contains?: String;
  referees_not_contains?: String;
  referees_starts_with?: String;
  referees_not_starts_with?: String;
  referees_ends_with?: String;
  referees_not_ends_with?: String;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: MatchScalarWhereInput[] | MatchScalarWhereInput;
  OR?: MatchScalarWhereInput[] | MatchScalarWhereInput;
  NOT?: MatchScalarWhereInput[] | MatchScalarWhereInput;
}

export interface MatchUpdateManyWithWhereNestedInput {
  where: MatchScalarWhereInput;
  data: MatchUpdateManyDataInput;
}

export interface MatchUpdateManyDataInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  win?: Boolean;
  competition?: Competiton;
  referees?: String;
  desc?: String;
}

export interface PlayerUpsertWithoutGoalsInput {
  update: PlayerUpdateWithoutGoalsDataInput;
  create: PlayerCreateWithoutGoalsInput;
}

export interface GoalUpsertWithWhereUniqueWithoutMatchInput {
  where: GoalWhereUniqueInput;
  update: GoalUpdateWithoutMatchDataInput;
  create: GoalCreateWithoutMatchInput;
}

export interface GoalScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  min?: Float;
  min_not?: Float;
  min_in?: Float[] | Float;
  min_not_in?: Float[] | Float;
  min_lt?: Float;
  min_lte?: Float;
  min_gt?: Float;
  min_gte?: Float;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: GoalScalarWhereInput[] | GoalScalarWhereInput;
  OR?: GoalScalarWhereInput[] | GoalScalarWhereInput;
  NOT?: GoalScalarWhereInput[] | GoalScalarWhereInput;
}

export interface GoalUpdateManyWithWhereNestedInput {
  where: GoalScalarWhereInput;
  data: GoalUpdateManyDataInput;
}

export interface GoalUpdateManyDataInput {
  min?: Float;
  desc?: String;
}

export interface MatchUpsertWithWhereUniqueWithoutLineupInput {
  where: MatchWhereUniqueInput;
  update: MatchUpdateWithoutLineupDataInput;
  create: MatchCreateWithoutLineupInput;
}

export interface PlayerUpsertWithWhereUniqueWithoutBenchInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutBenchDataInput;
  create: PlayerCreateWithoutBenchInput;
}

export interface PlayerScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nick?: String;
  nick_not?: String;
  nick_in?: String[] | String;
  nick_not_in?: String[] | String;
  nick_lt?: String;
  nick_lte?: String;
  nick_gt?: String;
  nick_gte?: String;
  nick_contains?: String;
  nick_not_contains?: String;
  nick_starts_with?: String;
  nick_not_starts_with?: String;
  nick_ends_with?: String;
  nick_not_ends_with?: String;
  shirtNumber?: Int;
  shirtNumber_not?: Int;
  shirtNumber_in?: Int[] | Int;
  shirtNumber_not_in?: Int[] | Int;
  shirtNumber_lt?: Int;
  shirtNumber_lte?: Int;
  shirtNumber_gt?: Int;
  shirtNumber_gte?: Int;
  imgUrl?: String;
  imgUrl_not?: String;
  imgUrl_in?: String[] | String;
  imgUrl_not_in?: String[] | String;
  imgUrl_lt?: String;
  imgUrl_lte?: String;
  imgUrl_gt?: String;
  imgUrl_gte?: String;
  imgUrl_contains?: String;
  imgUrl_not_contains?: String;
  imgUrl_starts_with?: String;
  imgUrl_not_starts_with?: String;
  imgUrl_ends_with?: String;
  imgUrl_not_ends_with?: String;
  captain?: Boolean;
  captain_not?: Boolean;
  position?: PlayerPosition;
  position_not?: PlayerPosition;
  position_in?: PlayerPosition[] | PlayerPosition;
  position_not_in?: PlayerPosition[] | PlayerPosition;
  altPosition?: PlayerPosition;
  altPosition_not?: PlayerPosition;
  altPosition_in?: PlayerPosition[] | PlayerPosition;
  altPosition_not_in?: PlayerPosition[] | PlayerPosition;
  foot?: Foot;
  foot_not?: Foot;
  foot_in?: Foot[] | Foot;
  foot_not_in?: Foot[] | Foot;
  injured?: Boolean;
  injured_not?: Boolean;
  AND?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  OR?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
  NOT?: PlayerScalarWhereInput[] | PlayerScalarWhereInput;
}

export interface PlayerUpdateManyWithWhereNestedInput {
  where: PlayerScalarWhereInput;
  data: PlayerUpdateManyDataInput;
}

export interface PlayerUpdateManyDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  captain?: Boolean;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  foot?: Foot;
  injured?: Boolean;
}

export interface MatchUpsertWithoutBookingsInput {
  update: MatchUpdateWithoutBookingsDataInput;
  create: MatchCreateWithoutBookingsInput;
}

export interface BookingUpsertWithWhereUniqueWithoutPlayerInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutPlayerDataInput;
  create: BookingCreateWithoutPlayerInput;
}

export interface PlayerUpsertWithWhereUniqueWithoutLineupInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutLineupDataInput;
  create: PlayerCreateWithoutLineupInput;
}

export interface MatchUpsertWithoutAssistInput {
  update: MatchUpdateWithoutAssistDataInput;
  create: MatchCreateWithoutAssistInput;
}

export interface AssistUpsertWithWhereUniqueWithoutPlayerInput {
  where: AssistWhereUniqueInput;
  update: AssistUpdateWithoutPlayerDataInput;
  create: AssistCreateWithoutPlayerInput;
}

export interface PlayerUpsertNestedInput {
  update: PlayerUpdateDataInput;
  create: PlayerCreateInput;
}

export interface MatchUpsertWithoutGoalsInput {
  update: MatchUpdateWithoutGoalsDataInput;
  create: MatchCreateWithoutGoalsInput;
}

export interface GoalUpsertWithWhereUniqueWithoutPlayerInput {
  where: GoalWhereUniqueInput;
  update: GoalUpdateWithoutPlayerDataInput;
  create: GoalCreateWithoutPlayerInput;
}

export interface PlayerUpsertWithWhereUniqueWithoutTeamInput {
  where: PlayerWhereUniqueInput;
  update: PlayerUpdateWithoutTeamDataInput;
  create: PlayerCreateWithoutTeamInput;
}

export interface TeamUpsertNestedInput {
  update: TeamUpdateDataInput;
  create: TeamCreateInput;
}

export interface MatchUpsertWithWhereUniqueWithoutStaffInput {
  where: MatchWhereUniqueInput;
  update: MatchUpdateWithoutStaffDataInput;
  create: MatchCreateWithoutStaffInput;
}

export interface StaffUpsertWithWhereUniqueWithoutTeamInput {
  where: StaffWhereUniqueInput;
  update: StaffUpdateWithoutTeamDataInput;
  create: StaffCreateWithoutTeamInput;
}

export interface TeamUpsertWithoutPlayersInput {
  update: TeamUpdateWithoutPlayersDataInput;
  create: TeamCreateWithoutPlayersInput;
}

export interface PlayerUpsertWithoutAssistInput {
  update: PlayerUpdateWithoutAssistDataInput;
  create: PlayerCreateWithoutAssistInput;
}

export interface AssistUpdateManyMutationInput {
  min?: Float;
  desc?: String;
}

export interface BookingCreateInput {
  id?: ID_Input;
  player: PlayerCreateOneWithoutBookingsInput;
  match: MatchCreateOneWithoutBookingsInput;
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface BookingUpdateInput {
  player?: PlayerUpdateOneRequiredWithoutBookingsInput;
  match?: MatchUpdateOneRequiredWithoutBookingsInput;
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface BookingUpdateManyMutationInput {
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface GoalCreateInput {
  id?: ID_Input;
  player: PlayerCreateOneWithoutGoalsInput;
  match: MatchCreateOneWithoutGoalsInput;
  min?: Float;
  desc?: String;
}

export interface GoalUpdateInput {
  player?: PlayerUpdateOneRequiredWithoutGoalsInput;
  match?: MatchUpdateOneRequiredWithoutGoalsInput;
  min?: Float;
  desc?: String;
}

export interface GoalUpdateManyMutationInput {
  min?: Float;
  desc?: String;
}

export interface InjuryCreateInput {
  id?: ID_Input;
  startAt: DateTimeInput;
  endAt?: DateTimeInput;
  desc: String;
  player?: PlayerCreateOneWithoutInjuryInput;
}

export interface PlayerCreateOneWithoutInjuryInput {
  create?: PlayerCreateWithoutInjuryInput;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerCreateWithoutInjuryInput {
  id?: ID_Input;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  team?: TeamCreateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoCreateOneInput;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentCreateOneInput;
  foot?: Foot;
  from?: WhereFromCreateOneInput;
  injured?: Boolean;
  sizes?: SizeCreateOneInput;
  goals?: GoalCreateManyWithoutPlayerInput;
  assist?: AssistCreateManyWithoutPlayerInput;
  bookings?: BookingCreateManyWithoutPlayerInput;
  lineup?: MatchCreateManyWithoutLineupInput;
  bench?: MatchCreateManyWithoutBenchInput;
}

export interface InjuryUpdateInput {
  startAt?: DateTimeInput;
  endAt?: DateTimeInput;
  desc?: String;
  player?: PlayerUpdateOneWithoutInjuryInput;
}

export interface PlayerUpdateOneWithoutInjuryInput {
  create?: PlayerCreateWithoutInjuryInput;
  update?: PlayerUpdateWithoutInjuryDataInput;
  upsert?: PlayerUpsertWithoutInjuryInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PlayerWhereUniqueInput;
}

export interface PlayerUpdateWithoutInjuryDataInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  sizes?: SizeUpdateOneInput;
  goals?: GoalUpdateManyWithoutPlayerInput;
  assist?: AssistUpdateManyWithoutPlayerInput;
  bookings?: BookingUpdateManyWithoutPlayerInput;
  lineup?: MatchUpdateManyWithoutLineupInput;
  bench?: MatchUpdateManyWithoutBenchInput;
}

export interface PlayerUpsertWithoutInjuryInput {
  update: PlayerUpdateWithoutInjuryDataInput;
  create: PlayerCreateWithoutInjuryInput;
}

export interface InjuryUpdateManyMutationInput {
  startAt?: DateTimeInput;
  endAt?: DateTimeInput;
  desc?: String;
}

export interface MatchCreateInput {
  id?: ID_Input;
  date?: DateTimeInput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamCreateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain: PlayerCreateOneInput;
  staff?: StaffCreateManyWithoutMatchesInput;
  lineup?: PlayerCreateManyWithoutLineupInput;
  bench?: PlayerCreateManyWithoutBenchInput;
  score: ScoreCreateOneInput;
  goals?: GoalCreateManyWithoutMatchInput;
  assist?: AssistCreateManyWithoutMatchInput;
  substitutions?: SubstitutionsCreateManyInput;
  bookings?: BookingCreateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface MatchUpdateInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  opponent?: TeamUpdateOneInput;
  win?: Boolean;
  competition?: Competiton;
  captain?: PlayerUpdateOneRequiredInput;
  staff?: StaffUpdateManyWithoutMatchesInput;
  lineup?: PlayerUpdateManyWithoutLineupInput;
  bench?: PlayerUpdateManyWithoutBenchInput;
  score?: ScoreUpdateOneRequiredInput;
  goals?: GoalUpdateManyWithoutMatchInput;
  assist?: AssistUpdateManyWithoutMatchInput;
  substitutions?: SubstitutionsUpdateManyInput;
  bookings?: BookingUpdateManyWithoutMatchInput;
  referees?: String;
  desc?: String;
}

export interface MatchUpdateManyMutationInput {
  date?: DateTimeInput;
  jornada?: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  win?: Boolean;
  competition?: Competiton;
  referees?: String;
  desc?: String;
}

export interface PlayerUpdateInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutPlayersInput;
  captain?: Boolean;
  personalInfo?: PersonalInfoUpdateOneInput;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: AssessmentUpdateOneInput;
  foot?: Foot;
  from?: WhereFromUpdateOneInput;
  injured?: Boolean;
  injury?: InjuryUpdateManyWithoutPlayerInput;
  sizes?: SizeUpdateOneInput;
  goals?: GoalUpdateManyWithoutPlayerInput;
  assist?: AssistUpdateManyWithoutPlayerInput;
  bookings?: BookingUpdateManyWithoutPlayerInput;
  lineup?: MatchUpdateManyWithoutLineupInput;
  bench?: MatchUpdateManyWithoutBenchInput;
}

export interface PlayerUpdateManyMutationInput {
  nick?: String;
  shirtNumber?: Int;
  imgUrl?: String;
  captain?: Boolean;
  position?: PlayerPosition;
  altPosition?: PlayerPosition;
  foot?: Foot;
  injured?: Boolean;
}

export interface StaffCreateInput {
  id?: ID_Input;
  nick: String;
  imgUrl?: String;
  team?: TeamCreateOneWithoutStaffInput;
  personalInfo?: StaffInfoCreateOneInput;
  from?: StaffFromCreateOneInput;
  sizes?: StaffSizeCreateOneInput;
  role?: String;
  matches?: MatchCreateManyWithoutStaffInput;
}

export interface StaffUpdateInput {
  nick?: String;
  imgUrl?: String;
  team?: TeamUpdateOneWithoutStaffInput;
  personalInfo?: StaffInfoUpdateOneInput;
  from?: StaffFromUpdateOneInput;
  sizes?: StaffSizeUpdateOneInput;
  role?: String;
  matches?: MatchUpdateManyWithoutStaffInput;
}

export interface StaffUpdateManyMutationInput {
  nick?: String;
  imgUrl?: String;
  role?: String;
}

export interface TeamUpdateInput {
  logoUrl?: String;
  name?: String;
  players?: PlayerUpdateManyWithoutTeamInput;
  staff?: StaffUpdateManyWithoutTeamInput;
}

export interface TeamUpdateManyMutationInput {
  logoUrl?: String;
  name?: String;
}

export interface AssistSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AssistWhereInput;
  AND?: AssistSubscriptionWhereInput[] | AssistSubscriptionWhereInput;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingWhereInput;
  AND?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
}

export interface GoalSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GoalWhereInput;
  AND?: GoalSubscriptionWhereInput[] | GoalSubscriptionWhereInput;
}

export interface InjurySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InjuryWhereInput;
  AND?: InjurySubscriptionWhereInput[] | InjurySubscriptionWhereInput;
}

export interface MatchSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MatchWhereInput;
  AND?: MatchSubscriptionWhereInput[] | MatchSubscriptionWhereInput;
}

export interface PlayerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlayerWhereInput;
  AND?: PlayerSubscriptionWhereInput[] | PlayerSubscriptionWhereInput;
}

export interface StaffSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StaffWhereInput;
  AND?: StaffSubscriptionWhereInput[] | StaffSubscriptionWhereInput;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TeamWhereInput;
  AND?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Assist {
  id: ID_Output;
  min?: Float;
  desc?: String;
}

export interface AssistPromise extends Promise<Assist>, Fragmentable {
  id: () => Promise<ID_Output>;
  player: <T = PlayerPromise>() => T;
  match: <T = MatchPromise>() => T;
  min: () => Promise<Float>;
  desc: () => Promise<String>;
}

export interface AssistSubscription
  extends Promise<AsyncIterator<Assist>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  player: <T = PlayerSubscription>() => T;
  match: <T = MatchSubscription>() => T;
  min: () => Promise<AsyncIterator<Float>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface Player {
  id: ID_Output;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  captain?: Boolean;
  personalInfo?: PersonalInfo | null;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  assessment?: Assessment | null;
  foot?: Foot;
  from?: WhereFrom | null;
  injured?: Boolean;
  sizes?: Size | null;
}

export interface PlayerPromise extends Promise<Player>, Fragmentable {
  id: () => Promise<ID_Output>;
  nick: () => Promise<String>;
  shirtNumber: () => Promise<Int>;
  imgUrl: () => Promise<String>;
  team: <T = TeamPromise>() => T;
  captain: () => Promise<Boolean>;
  personalInfo: <T = PersonalInfoPromise>() => T;
  position: () => Promise<PlayerPosition>;
  altPosition: () => Promise<PlayerPosition>;
  assessment: <T = AssessmentPromise>() => T;
  foot: () => Promise<Foot>;
  from: <T = WhereFromPromise>() => T;
  injured: () => Promise<Boolean>;
  injury: <T = FragmentableArray<Injury>>(
    args?: {
      where?: InjuryWhereInput;
      orderBy?: InjuryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sizes: <T = SizePromise>() => T;
  goals: <T = FragmentableArray<Goal>>(
    args?: {
      where?: GoalWhereInput;
      orderBy?: GoalOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  assist: <T = FragmentableArray<Assist>>(
    args?: {
      where?: AssistWhereInput;
      orderBy?: AssistOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookings: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  lineup: <T = FragmentableArray<Match>>(
    args?: {
      where?: MatchWhereInput;
      orderBy?: MatchOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bench: <T = FragmentableArray<Match>>(
    args?: {
      where?: MatchWhereInput;
      orderBy?: MatchOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PlayerSubscription
  extends Promise<AsyncIterator<Player>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nick: () => Promise<AsyncIterator<String>>;
  shirtNumber: () => Promise<AsyncIterator<Int>>;
  imgUrl: () => Promise<AsyncIterator<String>>;
  team: <T = TeamSubscription>() => T;
  captain: () => Promise<AsyncIterator<Boolean>>;
  personalInfo: <T = PersonalInfoSubscription>() => T;
  position: () => Promise<AsyncIterator<PlayerPosition>>;
  altPosition: () => Promise<AsyncIterator<PlayerPosition>>;
  assessment: <T = AssessmentSubscription>() => T;
  foot: () => Promise<AsyncIterator<Foot>>;
  from: <T = WhereFromSubscription>() => T;
  injured: () => Promise<AsyncIterator<Boolean>>;
  injury: <T = Promise<AsyncIterator<InjurySubscription>>>(
    args?: {
      where?: InjuryWhereInput;
      orderBy?: InjuryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sizes: <T = SizeSubscription>() => T;
  goals: <T = Promise<AsyncIterator<GoalSubscription>>>(
    args?: {
      where?: GoalWhereInput;
      orderBy?: GoalOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  assist: <T = Promise<AsyncIterator<AssistSubscription>>>(
    args?: {
      where?: AssistWhereInput;
      orderBy?: AssistOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  lineup: <T = Promise<AsyncIterator<MatchSubscription>>>(
    args?: {
      where?: MatchWhereInput;
      orderBy?: MatchOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bench: <T = Promise<AsyncIterator<MatchSubscription>>>(
    args?: {
      where?: MatchWhereInput;
      orderBy?: MatchOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Team {
  id: ID_Output;
  logoUrl?: String;
  name: String;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  id: () => Promise<ID_Output>;
  logoUrl: () => Promise<String>;
  name: () => Promise<String>;
  players: <T = FragmentableArray<Player>>(
    args?: {
      where?: PlayerWhereInput;
      orderBy?: PlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  staff: <T = FragmentableArray<Staff>>(
    args?: {
      where?: StaffWhereInput;
      orderBy?: StaffOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  logoUrl: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  players: <T = Promise<AsyncIterator<PlayerSubscription>>>(
    args?: {
      where?: PlayerWhereInput;
      orderBy?: PlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  staff: <T = Promise<AsyncIterator<StaffSubscription>>>(
    args?: {
      where?: StaffWhereInput;
      orderBy?: StaffOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Staff {
  id: ID_Output;
  nick: String;
  imgUrl?: String;
  personalInfo?: StaffInfo | null;
  from?: StaffFrom | null;
  sizes?: StaffSize | null;
  role?: String;
}

export interface StaffPromise extends Promise<Staff>, Fragmentable {
  id: () => Promise<ID_Output>;
  nick: () => Promise<String>;
  imgUrl: () => Promise<String>;
  team: <T = TeamPromise>() => T;
  personalInfo: <T = StaffInfoPromise>() => T;
  from: <T = StaffFromPromise>() => T;
  sizes: <T = StaffSizePromise>() => T;
  role: () => Promise<String>;
  matches: <T = FragmentableArray<Match>>(
    args?: {
      where?: MatchWhereInput;
      orderBy?: MatchOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StaffSubscription
  extends Promise<AsyncIterator<Staff>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nick: () => Promise<AsyncIterator<String>>;
  imgUrl: () => Promise<AsyncIterator<String>>;
  team: <T = TeamSubscription>() => T;
  personalInfo: <T = StaffInfoSubscription>() => T;
  from: <T = StaffFromSubscription>() => T;
  sizes: <T = StaffSizeSubscription>() => T;
  role: () => Promise<AsyncIterator<String>>;
  matches: <T = Promise<AsyncIterator<MatchSubscription>>>(
    args?: {
      where?: MatchWhereInput;
      orderBy?: MatchOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StaffInfo {
  name: String;
  firstName: String;
  lastName?: String;
  dateOfBirth?: DateTimeOutput;
  tel?: Int;
  email?: String;
  dni: String;
}

export interface StaffInfoPromise extends Promise<StaffInfo>, Fragmentable {
  name: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  tel: () => Promise<Int>;
  email: () => Promise<String>;
  dni: () => Promise<String>;
}

export interface StaffInfoSubscription
  extends Promise<AsyncIterator<StaffInfo>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  tel: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  dni: () => Promise<AsyncIterator<String>>;
}

export interface StaffFrom {
  address?: String;
  number?: Int;
  town?: String;
  province?: String;
  countruy?: String;
  PC?: Int;
}

export interface StaffFromPromise extends Promise<StaffFrom>, Fragmentable {
  address: () => Promise<String>;
  number: () => Promise<Int>;
  town: () => Promise<String>;
  province: () => Promise<String>;
  countruy: () => Promise<String>;
  PC: () => Promise<Int>;
}

export interface StaffFromSubscription
  extends Promise<AsyncIterator<StaffFrom>>,
    Fragmentable {
  address: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  town: () => Promise<AsyncIterator<String>>;
  province: () => Promise<AsyncIterator<String>>;
  countruy: () => Promise<AsyncIterator<String>>;
  PC: () => Promise<AsyncIterator<Int>>;
}

export interface StaffSize {
  clothing?: String;
  step?: Int;
}

export interface StaffSizePromise extends Promise<StaffSize>, Fragmentable {
  clothing: () => Promise<String>;
  step: () => Promise<Int>;
}

export interface StaffSizeSubscription
  extends Promise<AsyncIterator<StaffSize>>,
    Fragmentable {
  clothing: () => Promise<AsyncIterator<String>>;
  step: () => Promise<AsyncIterator<Int>>;
}

export interface Match {
  id: ID_Output;
  date?: DateTimeOutput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  win?: Boolean;
  competition?: Competiton;
  score: Score;
  substitutions?: <T = FragmentableArray<Substitutions>>() => T;
  referees?: String;
  desc?: String;
}

export interface MatchPromise extends Promise<Match>, Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  jornada: () => Promise<Int>;
  finished: () => Promise<Boolean>;
  homeTeam: () => Promise<Boolean>;
  opponent: <T = TeamPromise>() => T;
  win: () => Promise<Boolean>;
  competition: () => Promise<Competiton>;
  captain: <T = PlayerPromise>() => T;
  staff: <T = FragmentableArray<Staff>>(
    args?: {
      where?: StaffWhereInput;
      orderBy?: StaffOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  lineup: <T = FragmentableArray<Player>>(
    args?: {
      where?: PlayerWhereInput;
      orderBy?: PlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bench: <T = FragmentableArray<Player>>(
    args?: {
      where?: PlayerWhereInput;
      orderBy?: PlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  score: <T = ScorePromise>() => T;
  goals: <T = FragmentableArray<Goal>>(
    args?: {
      where?: GoalWhereInput;
      orderBy?: GoalOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  assist: <T = FragmentableArray<Assist>>(
    args?: {
      where?: AssistWhereInput;
      orderBy?: AssistOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  substitutions: <T = FragmentableArray<Substitutions>>() => T;
  bookings: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  referees: () => Promise<String>;
  desc: () => Promise<String>;
}

export interface MatchSubscription
  extends Promise<AsyncIterator<Match>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  jornada: () => Promise<AsyncIterator<Int>>;
  finished: () => Promise<AsyncIterator<Boolean>>;
  homeTeam: () => Promise<AsyncIterator<Boolean>>;
  opponent: <T = TeamSubscription>() => T;
  win: () => Promise<AsyncIterator<Boolean>>;
  competition: () => Promise<AsyncIterator<Competiton>>;
  captain: <T = PlayerSubscription>() => T;
  staff: <T = Promise<AsyncIterator<StaffSubscription>>>(
    args?: {
      where?: StaffWhereInput;
      orderBy?: StaffOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  lineup: <T = Promise<AsyncIterator<PlayerSubscription>>>(
    args?: {
      where?: PlayerWhereInput;
      orderBy?: PlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bench: <T = Promise<AsyncIterator<PlayerSubscription>>>(
    args?: {
      where?: PlayerWhereInput;
      orderBy?: PlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  score: <T = ScoreSubscription>() => T;
  goals: <T = Promise<AsyncIterator<GoalSubscription>>>(
    args?: {
      where?: GoalWhereInput;
      orderBy?: GoalOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  assist: <T = Promise<AsyncIterator<AssistSubscription>>>(
    args?: {
      where?: AssistWhereInput;
      orderBy?: AssistOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  substitutions: <T = Promise<AsyncIterator<SubstitutionsSubscription>>>() => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  referees: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface Score {
  id: ID_Output;
  fullTime: HomeAndAway;
  halfTime?: HomeAndAway | null;
  extraTime?: HomeAndAway | null;
  penalties?: HomeAndAway | null;
}

export interface ScorePromise extends Promise<Score>, Fragmentable {
  id: () => Promise<ID_Output>;
  fullTime: <T = HomeAndAwayPromise>() => T;
  halfTime: <T = HomeAndAwayPromise>() => T;
  extraTime: <T = HomeAndAwayPromise>() => T;
  penalties: <T = HomeAndAwayPromise>() => T;
}

export interface ScoreSubscription
  extends Promise<AsyncIterator<Score>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fullTime: <T = HomeAndAwaySubscription>() => T;
  halfTime: <T = HomeAndAwaySubscription>() => T;
  extraTime: <T = HomeAndAwaySubscription>() => T;
  penalties: <T = HomeAndAwaySubscription>() => T;
}

export interface HomeAndAway {
  homeTeam?: Int;
  awayTeam?: Int;
}

export interface HomeAndAwayPromise extends Promise<HomeAndAway>, Fragmentable {
  homeTeam: () => Promise<Int>;
  awayTeam: () => Promise<Int>;
}

export interface HomeAndAwaySubscription
  extends Promise<AsyncIterator<HomeAndAway>>,
    Fragmentable {
  homeTeam: () => Promise<AsyncIterator<Int>>;
  awayTeam: () => Promise<AsyncIterator<Int>>;
}

export interface Goal {
  id: ID_Output;
  min?: Float;
  desc?: String;
}

export interface GoalPromise extends Promise<Goal>, Fragmentable {
  id: () => Promise<ID_Output>;
  player: <T = PlayerPromise>() => T;
  match: <T = MatchPromise>() => T;
  min: () => Promise<Float>;
  desc: () => Promise<String>;
}

export interface GoalSubscription
  extends Promise<AsyncIterator<Goal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  player: <T = PlayerSubscription>() => T;
  match: <T = MatchSubscription>() => T;
  min: () => Promise<AsyncIterator<Float>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface Substitutions {
  id: ID_Output;
  min?: Float;
}

export interface SubstitutionsPromise
  extends Promise<Substitutions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  playerIn: <T = PlayerPromise>() => T;
  playerOut: <T = PlayerPromise>() => T;
  min: () => Promise<Float>;
}

export interface SubstitutionsSubscription
  extends Promise<AsyncIterator<Substitutions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  playerIn: <T = PlayerSubscription>() => T;
  playerOut: <T = PlayerSubscription>() => T;
  min: () => Promise<AsyncIterator<Float>>;
}

export interface Booking {
  id: ID_Output;
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  id: () => Promise<ID_Output>;
  player: <T = PlayerPromise>() => T;
  match: <T = MatchPromise>() => T;
  min: () => Promise<Float>;
  desc: () => Promise<String>;
  card: () => Promise<ColorCard>;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  player: <T = PlayerSubscription>() => T;
  match: <T = MatchSubscription>() => T;
  min: () => Promise<AsyncIterator<Float>>;
  desc: () => Promise<AsyncIterator<String>>;
  card: () => Promise<AsyncIterator<ColorCard>>;
}

export interface PersonalInfo {
  id: ID_Output;
  name: String;
  firstName: String;
  lastName?: String;
  dateOfBirth?: DateTimeOutput;
  tel?: Int;
  email?: String;
  dni: String;
  origin?: String;
  status?: String;
  childs?: Int;
  brothers?: Int;
  poscBrothers?: Int;
  clubBrothers?: Int;
}

export interface PersonalInfoPromise
  extends Promise<PersonalInfo>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  tel: () => Promise<Int>;
  email: () => Promise<String>;
  dni: () => Promise<String>;
  origin: () => Promise<String>;
  status: () => Promise<String>;
  childs: () => Promise<Int>;
  brothers: () => Promise<Int>;
  poscBrothers: () => Promise<Int>;
  clubBrothers: () => Promise<Int>;
}

export interface PersonalInfoSubscription
  extends Promise<AsyncIterator<PersonalInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  tel: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  dni: () => Promise<AsyncIterator<String>>;
  origin: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  childs: () => Promise<AsyncIterator<Int>>;
  brothers: () => Promise<AsyncIterator<Int>>;
  poscBrothers: () => Promise<AsyncIterator<Int>>;
  clubBrothers: () => Promise<AsyncIterator<Int>>;
}

export interface Assessment {
  id: ID_Output;
  personality?: Float;
  psychology?: Float;
  technical?: Float;
  tactical?: Float;
  physical?: Float;
}

export interface AssessmentPromise extends Promise<Assessment>, Fragmentable {
  id: () => Promise<ID_Output>;
  personality: () => Promise<Float>;
  psychology: () => Promise<Float>;
  technical: () => Promise<Float>;
  tactical: () => Promise<Float>;
  physical: () => Promise<Float>;
}

export interface AssessmentSubscription
  extends Promise<AsyncIterator<Assessment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  personality: () => Promise<AsyncIterator<Float>>;
  psychology: () => Promise<AsyncIterator<Float>>;
  technical: () => Promise<AsyncIterator<Float>>;
  tactical: () => Promise<AsyncIterator<Float>>;
  physical: () => Promise<AsyncIterator<Float>>;
}

export interface WhereFrom {
  id: ID_Output;
  address?: String;
  number?: Int;
  town?: String;
  province?: String;
  countruy?: String;
  PC?: Int;
  placeOfBirth?: String;
  nationality?: String;
  extra?: Boolean;
}

export interface WhereFromPromise extends Promise<WhereFrom>, Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  number: () => Promise<Int>;
  town: () => Promise<String>;
  province: () => Promise<String>;
  countruy: () => Promise<String>;
  PC: () => Promise<Int>;
  placeOfBirth: () => Promise<String>;
  nationality: () => Promise<String>;
  extra: () => Promise<Boolean>;
}

export interface WhereFromSubscription
  extends Promise<AsyncIterator<WhereFrom>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  town: () => Promise<AsyncIterator<String>>;
  province: () => Promise<AsyncIterator<String>>;
  countruy: () => Promise<AsyncIterator<String>>;
  PC: () => Promise<AsyncIterator<Int>>;
  placeOfBirth: () => Promise<AsyncIterator<String>>;
  nationality: () => Promise<AsyncIterator<String>>;
  extra: () => Promise<AsyncIterator<Boolean>>;
}

export interface Injury {
  id: ID_Output;
  startAt: DateTimeOutput;
  endAt?: DateTimeOutput;
  desc: String;
}

export interface InjuryPromise extends Promise<Injury>, Fragmentable {
  id: () => Promise<ID_Output>;
  startAt: () => Promise<DateTimeOutput>;
  endAt: () => Promise<DateTimeOutput>;
  desc: () => Promise<String>;
  player: <T = PlayerPromise>() => T;
}

export interface InjurySubscription
  extends Promise<AsyncIterator<Injury>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  desc: () => Promise<AsyncIterator<String>>;
  player: <T = PlayerSubscription>() => T;
}

export interface Size {
  id: ID_Output;
  clothing?: String;
  step?: Int;
}

export interface SizePromise extends Promise<Size>, Fragmentable {
  id: () => Promise<ID_Output>;
  clothing: () => Promise<String>;
  step: () => Promise<Int>;
}

export interface SizeSubscription
  extends Promise<AsyncIterator<Size>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  clothing: () => Promise<AsyncIterator<String>>;
  step: () => Promise<AsyncIterator<Int>>;
}

export interface AssistConnection {
  pageInfo: PageInfo;
  edges: AssistEdge[];
}

export interface AssistConnectionPromise
  extends Promise<AssistConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AssistEdge>>() => T;
  aggregate: <T = AggregateAssistPromise>() => T;
}

export interface AssistConnectionSubscription
  extends Promise<AsyncIterator<AssistConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AssistEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAssistSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AssistEdge {
  node: Assist;
  cursor: String;
}

export interface AssistEdgePromise extends Promise<AssistEdge>, Fragmentable {
  node: <T = AssistPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AssistEdgeSubscription
  extends Promise<AsyncIterator<AssistEdge>>,
    Fragmentable {
  node: <T = AssistSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAssist {
  count: Int;
}

export interface AggregateAssistPromise
  extends Promise<AggregateAssist>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAssistSubscription
  extends Promise<AsyncIterator<AggregateAssist>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingConnection {
  pageInfo: PageInfo;
  edges: BookingEdge[];
}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface BookingEdge {
  node: Booking;
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GoalConnection {
  pageInfo: PageInfo;
  edges: GoalEdge[];
}

export interface GoalConnectionPromise
  extends Promise<GoalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GoalEdge>>() => T;
  aggregate: <T = AggregateGoalPromise>() => T;
}

export interface GoalConnectionSubscription
  extends Promise<AsyncIterator<GoalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GoalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGoalSubscription>() => T;
}

export interface GoalEdge {
  node: Goal;
  cursor: String;
}

export interface GoalEdgePromise extends Promise<GoalEdge>, Fragmentable {
  node: <T = GoalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GoalEdgeSubscription
  extends Promise<AsyncIterator<GoalEdge>>,
    Fragmentable {
  node: <T = GoalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGoal {
  count: Int;
}

export interface AggregateGoalPromise
  extends Promise<AggregateGoal>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGoalSubscription
  extends Promise<AsyncIterator<AggregateGoal>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InjuryConnection {
  pageInfo: PageInfo;
  edges: InjuryEdge[];
}

export interface InjuryConnectionPromise
  extends Promise<InjuryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InjuryEdge>>() => T;
  aggregate: <T = AggregateInjuryPromise>() => T;
}

export interface InjuryConnectionSubscription
  extends Promise<AsyncIterator<InjuryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InjuryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInjurySubscription>() => T;
}

export interface InjuryEdge {
  node: Injury;
  cursor: String;
}

export interface InjuryEdgePromise extends Promise<InjuryEdge>, Fragmentable {
  node: <T = InjuryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InjuryEdgeSubscription
  extends Promise<AsyncIterator<InjuryEdge>>,
    Fragmentable {
  node: <T = InjurySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInjury {
  count: Int;
}

export interface AggregateInjuryPromise
  extends Promise<AggregateInjury>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInjurySubscription
  extends Promise<AsyncIterator<AggregateInjury>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MatchConnection {
  pageInfo: PageInfo;
  edges: MatchEdge[];
}

export interface MatchConnectionPromise
  extends Promise<MatchConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MatchEdge>>() => T;
  aggregate: <T = AggregateMatchPromise>() => T;
}

export interface MatchConnectionSubscription
  extends Promise<AsyncIterator<MatchConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MatchEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMatchSubscription>() => T;
}

export interface MatchEdge {
  node: Match;
  cursor: String;
}

export interface MatchEdgePromise extends Promise<MatchEdge>, Fragmentable {
  node: <T = MatchPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MatchEdgeSubscription
  extends Promise<AsyncIterator<MatchEdge>>,
    Fragmentable {
  node: <T = MatchSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMatch {
  count: Int;
}

export interface AggregateMatchPromise
  extends Promise<AggregateMatch>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMatchSubscription
  extends Promise<AsyncIterator<AggregateMatch>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlayerConnection {
  pageInfo: PageInfo;
  edges: PlayerEdge[];
}

export interface PlayerConnectionPromise
  extends Promise<PlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlayerEdge>>() => T;
  aggregate: <T = AggregatePlayerPromise>() => T;
}

export interface PlayerConnectionSubscription
  extends Promise<AsyncIterator<PlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlayerSubscription>() => T;
}

export interface PlayerEdge {
  node: Player;
  cursor: String;
}

export interface PlayerEdgePromise extends Promise<PlayerEdge>, Fragmentable {
  node: <T = PlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlayerEdgeSubscription
  extends Promise<AsyncIterator<PlayerEdge>>,
    Fragmentable {
  node: <T = PlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlayer {
  count: Int;
}

export interface AggregatePlayerPromise
  extends Promise<AggregatePlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlayerSubscription
  extends Promise<AsyncIterator<AggregatePlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StaffConnection {
  pageInfo: PageInfo;
  edges: StaffEdge[];
}

export interface StaffConnectionPromise
  extends Promise<StaffConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StaffEdge>>() => T;
  aggregate: <T = AggregateStaffPromise>() => T;
}

export interface StaffConnectionSubscription
  extends Promise<AsyncIterator<StaffConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StaffEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStaffSubscription>() => T;
}

export interface StaffEdge {
  node: Staff;
  cursor: String;
}

export interface StaffEdgePromise extends Promise<StaffEdge>, Fragmentable {
  node: <T = StaffPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StaffEdgeSubscription
  extends Promise<AsyncIterator<StaffEdge>>,
    Fragmentable {
  node: <T = StaffSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStaff {
  count: Int;
}

export interface AggregateStaffPromise
  extends Promise<AggregateStaff>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStaffSubscription
  extends Promise<AsyncIterator<AggregateStaff>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AssistSubscriptionPayload {
  mutation: MutationType;
  node: Assist;
  updatedFields: String[];
  previousValues: AssistPreviousValues;
}

export interface AssistSubscriptionPayloadPromise
  extends Promise<AssistSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AssistPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AssistPreviousValuesPromise>() => T;
}

export interface AssistSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AssistSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AssistSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AssistPreviousValuesSubscription>() => T;
}

export interface AssistPreviousValues {
  id: ID_Output;
  min?: Float;
  desc?: String;
}

export interface AssistPreviousValuesPromise
  extends Promise<AssistPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  min: () => Promise<Float>;
  desc: () => Promise<String>;
}

export interface AssistPreviousValuesSubscription
  extends Promise<AsyncIterator<AssistPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  min: () => Promise<AsyncIterator<Float>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  node: Booking;
  updatedFields: String[];
  previousValues: BookingPreviousValues;
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface BookingPreviousValues {
  id: ID_Output;
  min?: Float;
  desc?: String;
  card?: ColorCard;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  min: () => Promise<Float>;
  desc: () => Promise<String>;
  card: () => Promise<ColorCard>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  min: () => Promise<AsyncIterator<Float>>;
  desc: () => Promise<AsyncIterator<String>>;
  card: () => Promise<AsyncIterator<ColorCard>>;
}

export interface GoalSubscriptionPayload {
  mutation: MutationType;
  node: Goal;
  updatedFields: String[];
  previousValues: GoalPreviousValues;
}

export interface GoalSubscriptionPayloadPromise
  extends Promise<GoalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GoalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GoalPreviousValuesPromise>() => T;
}

export interface GoalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GoalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GoalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GoalPreviousValuesSubscription>() => T;
}

export interface GoalPreviousValues {
  id: ID_Output;
  min?: Float;
  desc?: String;
}

export interface GoalPreviousValuesPromise
  extends Promise<GoalPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  min: () => Promise<Float>;
  desc: () => Promise<String>;
}

export interface GoalPreviousValuesSubscription
  extends Promise<AsyncIterator<GoalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  min: () => Promise<AsyncIterator<Float>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface InjurySubscriptionPayload {
  mutation: MutationType;
  node: Injury;
  updatedFields: String[];
  previousValues: InjuryPreviousValues;
}

export interface InjurySubscriptionPayloadPromise
  extends Promise<InjurySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InjuryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InjuryPreviousValuesPromise>() => T;
}

export interface InjurySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InjurySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InjurySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InjuryPreviousValuesSubscription>() => T;
}

export interface InjuryPreviousValues {
  id: ID_Output;
  startAt: DateTimeOutput;
  endAt?: DateTimeOutput;
  desc: String;
}

export interface InjuryPreviousValuesPromise
  extends Promise<InjuryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startAt: () => Promise<DateTimeOutput>;
  endAt: () => Promise<DateTimeOutput>;
  desc: () => Promise<String>;
}

export interface InjuryPreviousValuesSubscription
  extends Promise<AsyncIterator<InjuryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface MatchSubscriptionPayload {
  mutation: MutationType;
  node: Match;
  updatedFields: String[];
  previousValues: MatchPreviousValues;
}

export interface MatchSubscriptionPayloadPromise
  extends Promise<MatchSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MatchPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MatchPreviousValuesPromise>() => T;
}

export interface MatchSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MatchSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MatchSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MatchPreviousValuesSubscription>() => T;
}

export interface MatchPreviousValues {
  id: ID_Output;
  date?: DateTimeOutput;
  jornada: Int;
  finished?: Boolean;
  homeTeam?: Boolean;
  win?: Boolean;
  competition?: Competiton;
  referees?: String;
  desc?: String;
}

export interface MatchPreviousValuesPromise
  extends Promise<MatchPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  jornada: () => Promise<Int>;
  finished: () => Promise<Boolean>;
  homeTeam: () => Promise<Boolean>;
  win: () => Promise<Boolean>;
  competition: () => Promise<Competiton>;
  referees: () => Promise<String>;
  desc: () => Promise<String>;
}

export interface MatchPreviousValuesSubscription
  extends Promise<AsyncIterator<MatchPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  jornada: () => Promise<AsyncIterator<Int>>;
  finished: () => Promise<AsyncIterator<Boolean>>;
  homeTeam: () => Promise<AsyncIterator<Boolean>>;
  win: () => Promise<AsyncIterator<Boolean>>;
  competition: () => Promise<AsyncIterator<Competiton>>;
  referees: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface PlayerSubscriptionPayload {
  mutation: MutationType;
  node: Player;
  updatedFields: String[];
  previousValues: PlayerPreviousValues;
}

export interface PlayerSubscriptionPayloadPromise
  extends Promise<PlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlayerPreviousValuesPromise>() => T;
}

export interface PlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlayerPreviousValuesSubscription>() => T;
}

export interface PlayerPreviousValues {
  id: ID_Output;
  nick: String;
  shirtNumber: Int;
  imgUrl?: String;
  captain?: Boolean;
  position: PlayerPosition;
  altPosition?: PlayerPosition;
  foot?: Foot;
  injured?: Boolean;
}

export interface PlayerPreviousValuesPromise
  extends Promise<PlayerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nick: () => Promise<String>;
  shirtNumber: () => Promise<Int>;
  imgUrl: () => Promise<String>;
  captain: () => Promise<Boolean>;
  position: () => Promise<PlayerPosition>;
  altPosition: () => Promise<PlayerPosition>;
  foot: () => Promise<Foot>;
  injured: () => Promise<Boolean>;
}

export interface PlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<PlayerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nick: () => Promise<AsyncIterator<String>>;
  shirtNumber: () => Promise<AsyncIterator<Int>>;
  imgUrl: () => Promise<AsyncIterator<String>>;
  captain: () => Promise<AsyncIterator<Boolean>>;
  position: () => Promise<AsyncIterator<PlayerPosition>>;
  altPosition: () => Promise<AsyncIterator<PlayerPosition>>;
  foot: () => Promise<AsyncIterator<Foot>>;
  injured: () => Promise<AsyncIterator<Boolean>>;
}

export interface StaffSubscriptionPayload {
  mutation: MutationType;
  node: Staff;
  updatedFields: String[];
  previousValues: StaffPreviousValues;
}

export interface StaffSubscriptionPayloadPromise
  extends Promise<StaffSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StaffPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StaffPreviousValuesPromise>() => T;
}

export interface StaffSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StaffSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StaffSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StaffPreviousValuesSubscription>() => T;
}

export interface StaffPreviousValues {
  id: ID_Output;
  nick: String;
  imgUrl?: String;
  role?: String;
}

export interface StaffPreviousValuesPromise
  extends Promise<StaffPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nick: () => Promise<String>;
  imgUrl: () => Promise<String>;
  role: () => Promise<String>;
}

export interface StaffPreviousValuesSubscription
  extends Promise<AsyncIterator<StaffPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nick: () => Promise<AsyncIterator<String>>;
  imgUrl: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<String>>;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface TeamPreviousValues {
  id: ID_Output;
  logoUrl?: String;
  name: String;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  logoUrl: () => Promise<String>;
  name: () => Promise<String>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  logoUrl: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Player",
    embedded: false
  },
  {
    name: "PersonalInfo",
    embedded: true
  },
  {
    name: "WhereFrom",
    embedded: true
  },
  {
    name: "Assessment",
    embedded: true
  },
  {
    name: "Size",
    embedded: true
  },
  {
    name: "Injury",
    embedded: false
  },
  {
    name: "Match",
    embedded: false
  },
  {
    name: "Score",
    embedded: true
  },
  {
    name: "HomeAndAway",
    embedded: true
  },
  {
    name: "Substitutions",
    embedded: true
  },
  {
    name: "Goal",
    embedded: false
  },
  {
    name: "Assist",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "Team",
    embedded: false
  },
  {
    name: "Staff",
    embedded: false
  },
  {
    name: "StaffInfo",
    embedded: true
  },
  {
    name: "StaffFrom",
    embedded: true
  },
  {
    name: "StaffSize",
    embedded: true
  },
  {
    name: "PlayerPosition",
    embedded: false
  },
  {
    name: "Foot",
    embedded: false
  },
  {
    name: "ColorCard",
    embedded: false
  },
  {
    name: "Competiton",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
